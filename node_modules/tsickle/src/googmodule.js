/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define("tsickle/src/googmodule", ["require", "exports", "path", "typescript", "tsickle/src/transformer_util"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var path = require("path");
    var ts = require("typescript");
    var transformer_util_1 = require("tsickle/src/transformer_util");
    /**
     * Returns true if node is a property access of `child` on the identifier `parent`.
     */
    function isPropertyAccess(node, parent, child) {
        if (!ts.isPropertyAccessExpression(node))
            return false;
        return ts.isIdentifier(node.expression) && node.expression.escapedText === parent &&
            node.name.escapedText === child;
    }
    /** Returns true if expr is "module.exports = ...;". */
    function isModuleExportsAssignment(expr) {
        if (!ts.isBinaryExpression(expr.expression))
            return false;
        if (expr.expression.operatorToken.kind !== ts.SyntaxKind.EqualsToken)
            return false;
        return isPropertyAccess(expr.expression.left, 'module', 'exports');
    }
    /** Returns true if expr is "exports = ...;". */
    function isExportsAssignment(expr) {
        if (!ts.isBinaryExpression(expr.expression))
            return false;
        if (expr.expression.operatorToken.kind !== ts.SyntaxKind.EqualsToken)
            return false;
        return ts.isIdentifier(expr.expression.left) && expr.expression.left.text === 'exports';
    }
    /** isUseStrict returns true if node is a "use strict"; statement. */
    function isUseStrict(node) {
        if (node.kind !== ts.SyntaxKind.ExpressionStatement)
            return false;
        var exprStmt = node;
        var expr = exprStmt.expression;
        if (expr.kind !== ts.SyntaxKind.StringLiteral)
            return false;
        var literal = expr;
        return literal.text === 'use strict';
    }
    /**
     * TypeScript inserts the following code to mark ES moduels in CommonJS:
     *   Object.defineProperty(exports, "__esModule", { value: true });
     * This matches that code snippet.
     */
    function isEsModuleProperty(stmt) {
        // We're matching the explicit source text generated by the TS compiler.
        // Object.defineProperty(exports, "__esModule", { value: true });
        var expr = stmt.expression;
        if (!ts.isCallExpression(expr))
            return false;
        if (!isPropertyAccess(expr.expression, 'Object', 'defineProperty'))
            return false;
        if (expr.arguments.length !== 3)
            return false;
        var _a = __read(expr.arguments, 3), exp = _a[0], esM = _a[1], val = _a[2];
        if (!ts.isIdentifier(exp) || exp.escapedText !== 'exports')
            return false;
        if (!ts.isStringLiteral(esM) || esM.text !== '__esModule')
            return false;
        if (!ts.isObjectLiteralExpression(val) || val.properties.length !== 1)
            return false;
        var prop = val.properties[0];
        if (!ts.isPropertyAssignment(prop))
            return false;
        var ident = prop.name;
        if (!ident || !ts.isIdentifier(ident) || ident.text !== 'value')
            return false;
        return prop.initializer.kind === ts.SyntaxKind.TrueKeyword;
    }
    /**
     * Returns the string argument if call is of the form
     *   require('foo')
     */
    function extractRequire(call) {
        // Verify that the call is a call to require(...).
        if (call.expression.kind !== ts.SyntaxKind.Identifier)
            return null;
        var ident = call.expression;
        if (ident.escapedText !== 'require')
            return null;
        // Verify the call takes a single string argument and grab it.
        if (call.arguments.length !== 1)
            return null;
        var arg = call.arguments[0];
        if (arg.kind !== ts.SyntaxKind.StringLiteral)
            return null;
        return arg.text;
    }
    /** Creates a call expression corresponding to `goog.${methodName}(${literal})`. */
    function createGoogCall(methodName, literal) {
        return ts.createCall(ts.createPropertyAccess(ts.createIdentifier('goog'), methodName), undefined, [literal]);
    }
    /**
     * Extracts the namespace part of a goog: import URL, or returns null if the given import URL is not
     * a goog: import.
     *
     * For example, for `import 'goog:foo.Bar';`, returns `foo.Bar`.
     */
    function extractGoogNamespaceImport(tsImport) {
        if (tsImport.match(/^goog:/))
            return tsImport.substring('goog:'.length);
        return null;
    }
    exports.extractGoogNamespaceImport = extractGoogNamespaceImport;
    // Matches common extensions of TypeScript input filenames
    var TS_EXTENSIONS = /(\.ts|\.d\.ts|\.js|\.jsx|\.tsx)$/;
    /**
     * Convert from implicit `import {} from 'pkg'` to a full resolved file name, including any `/index`
     * suffix and also resolving path mappings. TypeScript and many module loaders support the
     * shorthand, but `goog.module` does not, so tsickle needs to resolve the module name shorthand
     * before generating `goog.module` names.
     */
    function resolveModuleName(_a, pathOfImportingFile, imported) {
        var options = _a.options, moduleResolutionHost = _a.moduleResolutionHost;
        // The strategy taken here is to use ts.resolveModuleName() to resolve the import to
        // a specific path, which resolves any /index and path mappings.
        var resolved = ts.resolveModuleName(imported, pathOfImportingFile, options, moduleResolutionHost);
        if (!resolved || !resolved.resolvedModule)
            return imported;
        var resolvedModule = resolved.resolvedModule.resolvedFileName;
        // Check if the resolution went into node_modules.
        // Note that the ResolvedModule returned by resolveModuleName() has an
        // attribute isExternalLibraryImport that is documented with
        // "True if resolvedFileName comes from node_modules", but actually it is just
        // true if the absolute path includes node_modules, and is always true when
        // tsickle itself is under a directory named node_modules.
        var relativeResolved = path.relative(options.rootDir || '', resolvedModule);
        if (relativeResolved.indexOf('node_modules') !== -1) {
            // Imports into node_modules resolve through package.json and must be
            // specially handled by the loader anyway.  Return the input.
            return imported;
        }
        // Otherwise return the full resolved file name. This path will be turned into a module name using
        // AnnotatorHost#pathToModuleName, which also takes care of baseUrl and rootDirs.
        return resolved.resolvedModule.resolvedFileName;
    }
    exports.resolveModuleName = resolveModuleName;
    /**
     * importPathToGoogNamespace converts a TS/ES module './import/path' into a goog.module compatible
     * namespace, handling regular imports and `goog:` namespace imports.
     */
    function importPathToGoogNamespace(host, file, tsImport) {
        var modName;
        var nsImport = extractGoogNamespaceImport(tsImport);
        if (nsImport !== null) {
            // This is a namespace import, of the form "goog:foo.bar".
            // Fix it to just "foo.bar".
            modName = nsImport;
        }
        else {
            if (host.convertIndexImportShorthand) {
                tsImport = resolveModuleName(host, file.fileName, tsImport);
            }
            modName = host.pathToModuleName(file.fileName, tsImport);
        }
        return transformer_util_1.createSingleQuoteStringLiteral(modName);
    }
    /**
     * Replace "module.exports = ..." with just "exports = ...". Returns null if `expr` is not an
     * exports assignment.
     */
    function rewriteModuleExportsAssignment(expr) {
        if (!ts.isBinaryExpression(expr.expression))
            return null;
        if (expr.expression.operatorToken.kind !== ts.SyntaxKind.EqualsToken)
            return null;
        if (!isPropertyAccess(expr.expression.left, 'module', 'exports'))
            return null;
        return ts.setOriginalNode(ts.setTextRange(ts.createStatement(ts.createAssignment(ts.createIdentifier('exports'), expr.expression.right)), expr), expr);
    }
    /**
     * commonJsToGoogmoduleTransformer returns a transformer factory that converts TypeScript's CommonJS
     * module emit to Closure Compiler compatible goog.module and goog.require statements.
     */
    function commonJsToGoogmoduleTransformer(host, modulesManifest, typeChecker, diagnostics) {
        return function (context) {
            // TS' CommonJS processing uses onSubstituteNode to, at the very end of processing, substitute
            // "modulename.default" for default imports. We intercept the substitution here, check if it's a
            // .default access, then check if the original node (and thus original import) was from a goog:
            // module, and if so, replace with just the module name.
            var previousOnSubstituteNode = context.onSubstituteNode;
            context.enableSubstitution(ts.SyntaxKind.PropertyAccessExpression);
            context.onSubstituteNode = function (hint, node) {
                node = previousOnSubstituteNode(hint, node);
                if (!ts.isPropertyAccessExpression(node))
                    return node;
                if (node.name.text !== 'default')
                    return node;
                if (!ts.isIdentifier(node.expression))
                    return node;
                // Find the import declaration this node comes from.
                // This may be the original node, if the identifier was transformed from it.
                var orig = ts.getOriginalNode(node.expression);
                var importExportDecl;
                if (ts.isImportDeclaration(orig) || ts.isExportDeclaration(orig)) {
                    importExportDecl = orig;
                }
                else {
                    // Alternatively, we can try to find the declaration of the symbol. This only works for
                    // user-written .default accesses, the generated ones do not have a symbol associated as
                    // they are only produced in the CommonJS transformation, after type checking.
                    var sym = typeChecker.getSymbolAtLocation(node.expression);
                    if (!sym)
                        return node;
                    var decls = sym.getDeclarations();
                    if (!decls || !decls.length)
                        return node;
                    var decl = decls[0];
                    if (decl.parent && decl.parent.parent && ts.isImportDeclaration(decl.parent.parent)) {
                        importExportDecl = decl.parent.parent;
                    }
                    else {
                        return node;
                    }
                }
                // If the import declaration's URL is a "goog:..." style namespace, then all ".default"
                // accesses on it should be replaced with the symbol itself.
                // This allows referring to the module-level export of a "goog.module" or "goog.provide" as if
                // it was an ES6 default export.
                if (extractGoogNamespaceImport(importExportDecl.moduleSpecifier.text)) {
                    // Substitute "foo.default" with just "foo".
                    return node.expression;
                }
                return node;
            };
            return function (sf) {
                var e_1, _a;
                // In TS2.9, transformers can receive Bundle objects, which this code cannot handle (given
                // that a bundle by definition cannot be a goog.module()). The cast through any is necessary
                // to remain compatible with earlier TS versions.
                // tslint:disable-next-line:no-any
                if (sf.kind !== ts.SyntaxKind.SourceFile)
                    return sf;
                // JS scripts (as opposed to modules), must not be rewritten to
                // goog.modules.
                if (host.isJsTranspilation && !isModule(sf)) {
                    return sf;
                }
                var moduleVarCounter = 1;
                /**
                 * Creates a new unique variable to assign side effect imports into. This allows us to re-use
                 * the variable later on for other imports of the same namespace.
                 */
                function nextModuleVar() {
                    return "tsickle_module_" + moduleVarCounter++ + "_";
                }
                /**
                 * Maps goog.require namespaces to the variable name they are assigned into. E.g.:
                 *     var $varName = goog.require('$namespace'));
                 */
                var namespaceToModuleVarName = new Map();
                /**
                 * maybeCreateGoogRequire returns a `goog.require()` call for the given CommonJS `require`
                 * call. Returns null if `call` is not a CommonJS require.
                 */
                function maybeCreateGoogRequire(original, call, newIdent) {
                    var importedUrl = extractRequire(call);
                    if (!importedUrl)
                        return null;
                    var imp = importPathToGoogNamespace(host, sf, importedUrl);
                    modulesManifest.addReferencedModule(sf.fileName, imp.text);
                    var ident = namespaceToModuleVarName.get(imp.text);
                    var initializer;
                    if (!ident) {
                        namespaceToModuleVarName.set(imp.text, newIdent);
                        initializer = createGoogCall('require', imp);
                    }
                    else {
                        initializer = ident;
                    }
                    // In JS modules it's recommended that users get a handle on the
                    // goog namespace via:
                    //
                    //    import * as goog from 'google3/javascript/closure/goog.js';
                    //
                    // In a goog.module we just want to access the global `goog` value,
                    // so we skip emitting that import as a goog.require.
                    // We check the goog module name so that we also catch relative imports.
                    if (newIdent.escapedText === 'goog' && imp.text === 'google3.javascript.closure.goog') {
                        return transformer_util_1.createNotEmittedStatementWithComments(sf, original);
                    }
                    var varDecl = ts.createVariableDeclaration(newIdent, /* type */ undefined, initializer);
                    var newStmt = ts.createVariableStatement(
                    /* modifiers */ undefined, ts.createVariableDeclarationList([varDecl], 
                    // Use 'const' in ES6 mode so Closure properly forwards type aliases.
                    host.es5Mode ? undefined : ts.NodeFlags.Const));
                    return ts.setOriginalNode(ts.setTextRange(newStmt, original), original);
                }
                /**
                 * Rewrite goog.declareModuleId to something that works in a goog.module.
                 *
                 * goog.declareModuleId exposes a JS module as a goog.module. After we
                 * convert the JS module to a goog.module, what we really want is to
                 * expose the current goog.module at two different module ids. This isn't
                 * possible with the public APIs, but we can make it work at runtime
                 * by writing a record to goog.loadedModules_.
                 *
                 * This only works at runtime, and would fail if compiled by closure
                 * compiler, but that's ok because we only transpile JS in development
                 * mode.
                 */
                function maybeRewriteDeclareModuleId(original, call) {
                    // Verify that the call is a call to goog.declareModuleId(...).
                    if (!ts.isPropertyAccessExpression(call.expression)) {
                        return null;
                    }
                    var propAccess = call.expression;
                    if (propAccess.name.escapedText !== 'declareModuleId') {
                        return null;
                    }
                    if (!ts.isIdentifier(propAccess.expression) ||
                        propAccess.expression.escapedText !== 'goog') {
                        return null;
                    }
                    // Verify the call takes a single string argument and grab it.
                    if (call.arguments.length !== 1) {
                        return null;
                    }
                    var arg = call.arguments[0];
                    if (!ts.isStringLiteral(arg)) {
                        return null;
                    }
                    var moduleId = arg.text;
                    // replace goog.declareModuleId['foo.bar'] with:
                    // goog.loadedModules_['foo.bar'] = {
                    //   exports: exports,
                    //   type: goog.ModuleType.GOOG,
                    //   moduleId: 'foo.bar'
                    // };
                    //
                    // For more info, see `goog.loadModule` in
                    // https://github.com/google/closure-library/blob/master/closure/goog/base.js
                    var newStmt = ts.createStatement(ts.createAssignment(ts.createElementAccess(ts.createPropertyAccess(ts.createIdentifier('goog'), ts.createIdentifier('loadedModules_')), transformer_util_1.createSingleQuoteStringLiteral(moduleId)), ts.createObjectLiteral([
                        ts.createPropertyAssignment('exports', ts.createIdentifier('exports')),
                        ts.createPropertyAssignment('type', ts.createPropertyAccess(ts.createPropertyAccess(ts.createIdentifier('goog'), ts.createIdentifier('ModuleType')), ts.createIdentifier('GOOG'))),
                        ts.createPropertyAssignment('moduleId', transformer_util_1.createSingleQuoteStringLiteral(moduleId)),
                    ])));
                    return ts.setOriginalNode(ts.setTextRange(newStmt, original), original);
                }
                /**
                 * maybeRewriteRequireTslib rewrites a require('tslib') calls to goog.require('tslib'). It
                 * returns the input statement untouched if it does not match.
                 */
                function maybeRewriteRequireTslib(stmt) {
                    if (!ts.isExpressionStatement(stmt))
                        return null;
                    if (!ts.isCallExpression(stmt.expression))
                        return null;
                    var callExpr = stmt.expression;
                    if (!ts.isIdentifier(callExpr.expression) || callExpr.expression.text !== 'require') {
                        return null;
                    }
                    if (callExpr.arguments.length !== 1)
                        return stmt;
                    var arg = callExpr.arguments[0];
                    if (!ts.isStringLiteral(arg) || arg.text !== 'tslib')
                        return null;
                    return ts.setOriginalNode(ts.setTextRange(ts.createStatement(createGoogCall('require', arg)), stmt), stmt);
                }
                /**
                 * visitTopLevelStatement implements the main CommonJS to goog.module conversion. It visits a
                 * SourceFile level statement and adds a (possibly) transformed representation of it into
                 * statements. It adds at least one node per statement to statements.
                 *
                 * visitTopLevelStatement:
                 * - converts require() calls to goog.require() calls, with or w/o var assignment
                 * - removes "use strict"; and "Object.defineProperty(__esModule)" statements
                 * - converts module.exports assignments to just exports assignments
                 * - splits __exportStar() calls into require and export (this needs two statements)
                 * - makes sure to only import each namespace exactly once, and use variables later on
                 */
                function visitTopLevelStatement(statements, sf, node) {
                    // Handle each particular case by adding node to statements, then return.
                    // For unhandled cases, break to jump to the default handling below.
                    // In JS transpilation mode, always rewrite `require('tslib')` to
                    // goog.require('tslib'), ignoring normal module resolution.
                    if (host.isJsTranspilation) {
                        var rewrittenTsLib = maybeRewriteRequireTslib(node);
                        if (rewrittenTsLib) {
                            statements.push(rewrittenTsLib);
                            return;
                        }
                    }
                    switch (node.kind) {
                        case ts.SyntaxKind.ExpressionStatement: {
                            var exprStmt = node;
                            // Check for "use strict" and certain Object.defineProperty and skip it if necessary.
                            if (isUseStrict(exprStmt) || isEsModuleProperty(exprStmt)) {
                                stmts.push(transformer_util_1.createNotEmittedStatementWithComments(sf, exprStmt));
                                return;
                            }
                            // Check for:
                            //   module.exports = ...;
                            var modExports = rewriteModuleExportsAssignment(exprStmt);
                            if (modExports) {
                                stmts.push(modExports);
                                return;
                            }
                            // Check for:
                            //   "require('foo');" (a require for its side effects)
                            var expr = exprStmt.expression;
                            if (!ts.isCallExpression(expr))
                                break;
                            var callExpr = expr;
                            var declaredModuleId = maybeRewriteDeclareModuleId(exprStmt, callExpr);
                            if (declaredModuleId) {
                                statements.push(declaredModuleId);
                                return;
                            }
                            // Handle export * in ES5 mode (in ES6 mode, export * is dereferenced already).
                            // export * creates either a pure top-level '__export(require(...))' or the imported
                            // version, 'tslib.__exportStar(require(...))'. The imported version is only substituted
                            // later on though, so appears as a plain "__exportStar" on the top level here.
                            var isExportStar = (ts.isIdentifier(expr.expression) && expr.expression.text === '__exportStar') ||
                                (ts.isIdentifier(expr.expression) && expr.expression.text === '__export');
                            if (isExportStar)
                                callExpr = expr.arguments[0];
                            var ident = ts.createIdentifier(nextModuleVar());
                            var require_1 = maybeCreateGoogRequire(exprStmt, callExpr, ident);
                            if (!require_1)
                                break;
                            statements.push(require_1);
                            // If this is an export star, split it up into the import (created by the maybe call
                            // above), and the export operation. This avoids a Closure complaint about non-top-level
                            // requires.
                            if (isExportStar) {
                                var args = [ident];
                                if (expr.arguments.length > 1)
                                    args.push(expr.arguments[1]);
                                statements.push(ts.createStatement(ts.createCall(expr.expression, undefined, args)));
                            }
                            return;
                        }
                        case ts.SyntaxKind.VariableStatement: {
                            // It's possibly of the form "var x = require(...);".
                            var varStmt = node;
                            // Verify it's a single decl (and not "var x = ..., y = ...;").
                            if (varStmt.declarationList.declarations.length !== 1)
                                break;
                            var decl = varStmt.declarationList.declarations[0];
                            // Grab the variable name (avoiding things like destructuring binds).
                            if (decl.name.kind !== ts.SyntaxKind.Identifier)
                                break;
                            if (!decl.initializer || !ts.isCallExpression(decl.initializer)) {
                                break;
                            }
                            var require_2 = maybeCreateGoogRequire(varStmt, decl.initializer, decl.name);
                            if (!require_2)
                                break;
                            statements.push(require_2);
                            return;
                        }
                        default:
                            break;
                    }
                    statements.push(node);
                }
                var moduleName = host.pathToModuleName('', sf.fileName);
                // Register the namespace this file provides.
                modulesManifest.addModule(sf.fileName, moduleName);
                // Convert each top level statement to goog.module.
                var stmts = [];
                try {
                    for (var _b = __values(sf.statements), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var stmt = _c.value;
                        visitTopLevelStatement(stmts, sf, stmt);
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                // Additional statements that will be prepended (goog.module call etc).
                var headerStmts = [];
                // Emit: goog.module('moduleName');
                var googModule = ts.createStatement(createGoogCall('module', transformer_util_1.createSingleQuoteStringLiteral(moduleName)));
                headerStmts.push(googModule);
                // Allow code to use `module.id` to discover its module URL, e.g. to resolve a template URL
                // against. Uses 'var', as this code is inserted in ES6 and ES5 modes. The following pattern
                // ensures closure doesn't throw an error in advanced optimizations mode.
                // var module = module || {id: 'path/to/module.ts'};
                var moduleId = host.fileNameToModuleId(sf.fileName);
                var moduleVarInitializer = ts.createBinary(ts.createIdentifier('module'), ts.SyntaxKind.BarBarToken, ts.createObjectLiteral([ts.createPropertyAssignment('id', transformer_util_1.createSingleQuoteStringLiteral(moduleId))]));
                var modAssign = ts.createVariableStatement(
                /* modifiers */ undefined, ts.createVariableDeclarationList([ts.createVariableDeclaration('module', /* type */ undefined, moduleVarInitializer)]));
                headerStmts.push(modAssign);
                if (!host.es5Mode) {
                    // The module=module assignment suppresses an unused variable warning which may trigger
                    // depending on the project's compilation flags.
                    headerStmts.push(ts.createStatement(ts.createAssignment(ts.createIdentifier('module'), ts.createIdentifier('module'))));
                    // The `exports = {}` serves as a default export to disable Closure Compiler's error
                    // checking
                    // for mutable exports. That's OK because TS compiler makes sure that consuming code always
                    // accesses exports through the module object, so mutable exports work.
                    // It is only inserted in ES6 because we strip `.default` accesses in ES5 mode, which breaks
                    // when assigning an `exports = {}` object and then later accessing it.
                    // However Closure bails if code later on assigns into exports directly, as we do if we have
                    // an "exports = " block, so skip emit if that's the case.
                    if (!sf.statements.find(function (s) { return ts.isExpressionStatement(s) &&
                        (isModuleExportsAssignment(s) || isExportsAssignment(s)); })) {
                        headerStmts.push(ts.createStatement(ts.createAssignment(ts.createIdentifier('exports'), ts.createObjectLiteral())));
                    }
                }
                // Insert goog.module() etc after any leading comments in the source file. The comments have
                // been converted to NotEmittedStatements by transformer_util, which this depends on.
                var insertionIdx = stmts.findIndex(function (s) { return s.kind !== ts.SyntaxKind.NotEmittedStatement; });
                if (insertionIdx === -1) {
                    stmts.push.apply(stmts, __spread(headerStmts));
                }
                else {
                    stmts.splice.apply(stmts, __spread([insertionIdx, 0], headerStmts));
                }
                return ts.updateSourceFileNode(sf, ts.setTextRange(ts.createNodeArray(stmts), sf.statements));
            };
        };
    }
    exports.commonJsToGoogmoduleTransformer = commonJsToGoogmoduleTransformer;
    function isModule(sourceFile) {
        return Boolean(sourceFile.externalModuleIndicator);
    }
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ29vZ21vZHVsZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9nb29nbW9kdWxlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7R0FNRzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBRUgsMkJBQTZCO0lBQzdCLCtCQUFpQztJQUdqQyxpRUFBMEc7SUF5QjFHOztPQUVHO0lBQ0gsU0FBUyxnQkFBZ0IsQ0FBQyxJQUFhLEVBQUUsTUFBYyxFQUFFLEtBQWE7UUFDcEUsSUFBSSxDQUFDLEVBQUUsQ0FBQywwQkFBMEIsQ0FBQyxJQUFJLENBQUM7WUFBRSxPQUFPLEtBQUssQ0FBQztRQUN2RCxPQUFPLEVBQUUsQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLElBQUksQ0FBQyxVQUFVLENBQUMsV0FBVyxLQUFLLE1BQU07WUFDN0UsSUFBSSxDQUFDLElBQUksQ0FBQyxXQUFXLEtBQUssS0FBSyxDQUFDO0lBQ3RDLENBQUM7SUFFRCx1REFBdUQ7SUFDdkQsU0FBUyx5QkFBeUIsQ0FBQyxJQUE0QjtRQUM3RCxJQUFJLENBQUMsRUFBRSxDQUFDLGtCQUFrQixDQUFDLElBQUksQ0FBQyxVQUFVLENBQUM7WUFBRSxPQUFPLEtBQUssQ0FBQztRQUMxRCxJQUFJLElBQUksQ0FBQyxVQUFVLENBQUMsYUFBYSxDQUFDLElBQUksS0FBSyxFQUFFLENBQUMsVUFBVSxDQUFDLFdBQVc7WUFBRSxPQUFPLEtBQUssQ0FBQztRQUNuRixPQUFPLGdCQUFnQixDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxFQUFFLFFBQVEsRUFBRSxTQUFTLENBQUMsQ0FBQztJQUNyRSxDQUFDO0lBRUQsZ0RBQWdEO0lBQ2hELFNBQVMsbUJBQW1CLENBQUMsSUFBNEI7UUFDdkQsSUFBSSxDQUFDLEVBQUUsQ0FBQyxrQkFBa0IsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDO1lBQUUsT0FB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QUN2QixLQUFLLENBQUMsSUFBSSxPQUFWLEtBQUssV0FBUyxXQUFXLEdBQUU7aUJBQzVCO3FCQUFNO29CQUNMLEtBQUssQ0FBQyxNQUFNLE9BQVosS0FBSyxZQUFRLFlBQVksRUFBRSxDQUFDLEdBQUssV0FBVyxHQUFFO2lCQUMvQztnQkFFRCxPQUFPLEVBQUUsQ0FBQyxvQkFBb0IsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLFlBQVksQ0FBQyxFQUFFLENBQUMsZUFBZSxDQUFDLEtBQUssQ0FBQyxFQUFFLEVBQUUsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDO1lBQ2hHLENBQUMsQ0FBQztRQUNKLENBQUMsQ0FBQztJQUNKLENBQUM7SUEzV0QsMEVBMldDO0lBRUQsU0FBUyxRQUFRLENBQUMsVUFBeUI7UUFNekMsT0FBTyxPQUFPLENBQUUsVUFBaUMsQ0FBQyx1QkFBdUIsQ0FBQyxDQUFDO0lBQzdFLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5cbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgKiBhcyB0cyBmcm9tICd0eXBlc2NyaXB0JztcblxuaW1wb3J0IHtNb2R1bGVzTWFuaWZlc3R9IGZyb20gJy4vbW9kdWxlc19tYW5pZmVzdCc7XG5pbXBvcnQge2NyZWF0ZU5vdEVtaXR0ZWRTdGF0ZW1lbnRXaXRoQ29tbWVudHMsIGNyZWF0ZVNpbmdsZVF1b3RlU3RyaW5nTGl0ZXJhbCx9IGZyb20gJy4vdHJhbnNmb3JtZXJfdXRpbCc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgR29vZ01vZHVsZVByb2Nlc3Nvckhvc3Qge1xuICAvKipcbiAgICogVGFrZXMgYSBjb250ZXh0ICh0cy5Tb3VyY2VGaWxlLmZpbGVOYW1lIG9mIHRoZSBjdXJyZW50IGZpbGUpIGFuZCB0aGUgaW1wb3J0IFVSTCBvZiBhbiBFUzZcbiAgICogaW1wb3J0IGFuZCBnZW5lcmF0ZXMgYSBnb29nbW9kdWxlIG1vZHVsZSBuYW1lIGZvciB0aGUgaW1wb3J0ZWQgbW9kdWxlLlxuICAgKi9cbiAgcGF0aFRvTW9kdWxlTmFtZShjb250ZXh0OiBzdHJpbmcsIGltcG9ydFBhdGg6IHN0cmluZyk6IHN0cmluZztcbiAgLyoqXG4gICAqIElmIHdlIGRvIGdvb2dtb2R1bGUgcHJvY2Vzc2luZywgd2UgcG9seWZpbGwgbW9kdWxlLmlkLCBzaW5jZSB0aGF0J3NcbiAgICogcGFydCBvZiBFUzYgbW9kdWxlcy4gIFRoaXMgZnVuY3Rpb24gZGV0ZXJtaW5lcyB3aGF0IHRoZSBtb2R1bGUuaWQgd2lsbCBiZVxuICAgKiBmb3IgZWFjaCBmaWxlLlxuICAgKi9cbiAgZmlsZU5hbWVUb01vZHVsZUlkKGZpbGVOYW1lOiBzdHJpbmcpOiBzdHJpbmc7XG4gIC8qKiBJZGVudGlmaWVzIHdoZXRoZXIgdGhpcyBmaWxlIGlzIHRoZSByZXN1bHQgb2YgYSBKUyB0cmFuc3BpbGF0aW9uLiAqL1xuICBpc0pzVHJhbnNwaWxhdGlvbj86IGJvb2xlYW47XG4gIC8qKiBXaGV0aGVyIHRoZSBlbWl0IHRhcmdldHMgRVM1IG9yIEVTNisuICovXG4gIGVzNU1vZGU/OiBib29sZWFuO1xuICAvKiogZXhwYW5kIFwiaW1wb3J0ICdmb28nO1wiIHRvIFwiaW1wb3J0ICdmb28vaW5kZXgnO1wiIGlmIGl0IHBvaW50cyB0byBhbiBpbmRleCBmaWxlLiAqL1xuICBjb252ZXJ0SW5kZXhJbXBvcnRTaG9ydGhhbmQ/OiBib29sZWFuO1xuXG4gIG9wdGlvbnM6IHRzLkNvbXBpbGVyT3B0aW9ucztcbiAgbW9kdWxlUmVzb2x1dGlvbkhvc3Q6IHRzLk1vZHVsZVJlc29sdXRpb25Ib3N0O1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBub2RlIGlzIGEgcHJvcGVydHkgYWNjZXNzIG9mIGBjaGlsZGAgb24gdGhlIGlkZW50aWZpZXIgYHBhcmVudGAuXG4gKi9cbmZ1bmN0aW9uIGlzUHJvcGVydHlBY2Nlc3Mobm9kZTogdHMuTm9kZSwgcGFyZW50OiBzdHJpbmcsIGNoaWxkOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgaWYgKCF0cy5pc1Byb3BlcnR5QWNjZXNzRXhwcmVzc2lvbihub2RlKSkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gdHMuaXNJZGVudGlmaWVyKG5vZGUuZXhwcmVzc2lvbikgJiYgbm9kZS5leHByZXNzaW9uLmVzY2FwZWRUZXh0ID09PSBwYXJlbnQgJiZcbiAgICAgIG5vZGUubmFtZS5lc2NhcGVkVGV4dCA9PT0gY2hpbGQ7XG59XG5cbi8qKiBSZXR1cm5zIHRydWUgaWYgZXhwciBpcyBcIm1vZHVsZS5leHBvcnRzID0gLi4uO1wiLiAqL1xuZnVuY3Rpb24gaXNNb2R1bGVFeHBvcnRzQXNzaWdubWVudChleHByOiB0cy5FeHByZXNzaW9uU3RhdGVtZW50KTogYm9vbGVhbiB7XG4gIGlmICghdHMuaXNCaW5hcnlFeHByZXNzaW9uKGV4cHIuZXhwcmVzc2lvbikpIHJldHVybiBmYWxzZTtcbiAgaWYgKGV4cHIuZXhwcmVzc2lvbi5vcGVyYXRvclRva2VuLmtpbmQgIT09IHRzLlN5bnRheEtpbmQuRXF1YWxzVG9rZW4pIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIGlzUHJvcGVydHlBY2Nlc3MoZXhwci5leHByZXNzaW9uLmxlZnQsICdtb2R1bGUnLCAnZXhwb3J0cycpO1xufVxuXG4vKiogUmV0dXJucyB0cnVlIGlmIGV4cHIgaXMgXCJleHBvcnRzID0gLi4uO1wiLiAqL1xuZnVuY3Rpb24gaXNFeHBvcnRzQXNzaWdubWVudChleHByOiB0cy5FeHByZXNzaW9uU3RhdGVtZW50KTogYm9vbGVhbiB7XG4gIGlmICghdHMuaXNCaW5hcnlFeHByZXNzaW9uKGV4cHIuZXhwcmVzc2lvbikpIHJldHVybiBmYWxzZTtcbiAgaWYgKGV4cHIuZXhwcmVzc2lvbi5vcGVyYXRvclRva2VuLmtpbmQgIT09IHRzLlN5bnRheEtpbmQuRXF1YWxzVG9rZW4pIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIHRzLmlzSWRlbnRpZmllcihleHByLmV4cHJlc3Npb24ubGVmdCkgJiYgZXhwci5leHByZXNzaW9uLmxlZnQudGV4dCA9PT0gJ2V4cG9ydHMnO1xufVxuXG4vKiogaXNVc2VTdHJpY3QgcmV0dXJucyB0cnVlIGlmIG5vZGUgaXMgYSBcInVzZSBzdHJpY3RcIjsgc3RhdGVtZW50LiAqL1xuZnVuY3Rpb24gaXNVc2VTdHJpY3Qobm9kZTogdHMuTm9kZSk6IGJvb2xlYW4ge1xuICBpZiAobm9kZS5raW5kICE9PSB0cy5TeW50YXhLaW5kLkV4cHJlc3Npb25TdGF0ZW1lbnQpIHJldHVybiBmYWxzZTtcbiAgY29uc3QgZXhwclN0bXQgPSBub2RlIGFzIHRzLkV4cHJlc3Npb25TdGF0ZW1lbnQ7XG4gIGNvbnN0IGV4cHIgPSBleHByU3RtdC5leHByZXNzaW9uO1xuICBpZiAoZXhwci5raW5kICE9PSB0cy5TeW50YXhLaW5kLlN0cmluZ0xpdGVyYWwpIHJldHVybiBmYWxzZTtcbiAgY29uc3QgbGl0ZXJhbCA9IGV4cHIgYXMgdHMuU3RyaW5nTGl0ZXJhbDtcbiAgcmV0dXJuIGxpdGVyYWwudGV4dCA9PT0gJ3VzZSBzdHJpY3QnO1xufVxuXG4vKipcbiAqIFR5cGVTY3JpcHQgaW5zZXJ0cyB0aGUgZm9sbG93aW5nIGNvZGUgdG8gbWFyayBFUyBtb2R1ZWxzIGluIENvbW1vbkpTOlxuICogICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4gKiBUaGlzIG1hdGNoZXMgdGhhdCBjb2RlIHNuaXBwZXQuXG4gKi9cbmZ1bmN0aW9uIGlzRXNNb2R1bGVQcm9wZXJ0eShzdG10OiB0cy5FeHByZXNzaW9uU3RhdGVtZW50KTogYm9vbGVhbiB7XG4gIC8vIFdlJ3JlIG1hdGNoaW5nIHRoZSBleHBsaWNpdCBzb3VyY2UgdGV4dCBnZW5lcmF0ZWQgYnkgdGhlIFRTIGNvbXBpbGVyLlxuICAvLyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4gIGNvbnN0IGV4cHIgPSBzdG10LmV4cHJlc3Npb247XG4gIGlmICghdHMuaXNDYWxsRXhwcmVzc2lvbihleHByKSkgcmV0dXJuIGZhbHNlO1xuICBpZiAoIWlzUHJvcGVydHlBY2Nlc3MoZXhwci5leHByZXNzaW9uLCAnT2JqZWN0JywgJ2RlZmluZVByb3BlcnR5JykpIHJldHVybiBmYWxzZTtcbiAgaWYgKGV4cHIuYXJndW1lbnRzLmxlbmd0aCAhPT0gMykgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBbZXhwLCBlc00sIHZhbF0gPSBleHByLmFyZ3VtZW50cztcbiAgaWYgKCF0cy5pc0lkZW50aWZpZXIoZXhwKSB8fCBleHAuZXNjYXBlZFRleHQgIT09ICdleHBvcnRzJykgcmV0dXJuIGZhbHNlO1xuICBpZiAoIXRzLmlzU3RyaW5nTGl0ZXJhbChlc00pIHx8IGVzTS50ZXh0ICE9PSAnX19lc01vZHVsZScpIHJldHVybiBmYWxzZTtcbiAgaWYgKCF0cy5pc09iamVjdExpdGVyYWxFeHByZXNzaW9uKHZhbCkgfHwgdmFsLnByb3BlcnRpZXMubGVuZ3RoICE9PSAxKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IHByb3AgPSB2YWwucHJvcGVydGllc1swXTtcbiAgaWYgKCF0cy5pc1Byb3BlcnR5QXNzaWdubWVudChwcm9wKSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBpZGVudCA9IHByb3AubmFtZTtcbiAgaWYgKCFpZGVudCB8fCAhdHMuaXNJZGVudGlmaWVyKGlkZW50KSB8fCBpZGVudC50ZXh0ICE9PSAndmFsdWUnKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBwcm9wLmluaXRpYWxpemVyLmtpbmQgPT09IHRzLlN5bnRheEtpbmQuVHJ1ZUtleXdvcmQ7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgc3RyaW5nIGFyZ3VtZW50IGlmIGNhbGwgaXMgb2YgdGhlIGZvcm1cbiAqICAgcmVxdWlyZSgnZm9vJylcbiAqL1xuZnVuY3Rpb24gZXh0cmFjdFJlcXVpcmUoY2FsbDogdHMuQ2FsbEV4cHJlc3Npb24pOiBzdHJpbmd8bnVsbCB7XG4gIC8vIFZlcmlmeSB0aGF0IHRoZSBjYWxsIGlzIGEgY2FsbCB0byByZXF1aXJlKC4uLikuXG4gIGlmIChjYWxsLmV4cHJlc3Npb24ua2luZCAhPT0gdHMuU3ludGF4S2luZC5JZGVudGlmaWVyKSByZXR1cm4gbnVsbDtcbiAgY29uc3QgaWRlbnQgPSBjYWxsLmV4cHJlc3Npb24gYXMgdHMuSWRlbnRpZmllcjtcbiAgaWYgKGlkZW50LmVzY2FwZWRUZXh0ICE9PSAncmVxdWlyZScpIHJldHVybiBudWxsO1xuXG4gIC8vIFZlcmlmeSB0aGUgY2FsbCB0YWtlcyBhIHNpbmdsZSBzdHJpbmcgYXJndW1lbnQgYW5kIGdyYWIgaXQuXG4gIGlmIChjYWxsLmFyZ3VtZW50cy5sZW5ndGggIT09IDEpIHJldHVybiBudWxsO1xuICBjb25zdCBhcmcgPSBjYWxsLmFyZ3VtZW50c1swXTtcbiAgaWYgKGFyZy5raW5kICE9PSB0cy5TeW50YXhLaW5kLlN0cmluZ0xpdGVyYWwpIHJldHVybiBudWxsO1xuICByZXR1cm4gKGFyZyBhcyB0cy5TdHJpbmdMaXRlcmFsKS50ZXh0O1xufVxuXG4vKiogQ3JlYXRlcyBhIGNhbGwgZXhwcmVzc2lvbiBjb3JyZXNwb25kaW5nIHRvIGBnb29nLiR7bWV0aG9kTmFtZX0oJHtsaXRlcmFsfSlgLiAqL1xuZnVuY3Rpb24gY3JlYXRlR29vZ0NhbGwobWV0aG9kTmFtZTogc3RyaW5nLCBsaXRlcmFsOiB0cy5TdHJpbmdMaXRlcmFsKTogdHMuQ2FsbEV4cHJlc3Npb24ge1xuICByZXR1cm4gdHMuY3JlYXRlQ2FsbChcbiAgICAgIHRzLmNyZWF0ZVByb3BlcnR5QWNjZXNzKHRzLmNyZWF0ZUlkZW50aWZpZXIoJ2dvb2cnKSwgbWV0aG9kTmFtZSksIHVuZGVmaW5lZCwgW2xpdGVyYWxdKTtcbn1cblxuLyoqXG4gKiBFeHRyYWN0cyB0aGUgbmFtZXNwYWNlIHBhcnQgb2YgYSBnb29nOiBpbXBvcnQgVVJMLCBvciByZXR1cm5zIG51bGwgaWYgdGhlIGdpdmVuIGltcG9ydCBVUkwgaXMgbm90XG4gKiBhIGdvb2c6IGltcG9ydC5cbiAqXG4gKiBGb3IgZXhhbXBsZSwgZm9yIGBpbXBvcnQgJ2dvb2c6Zm9vLkJhcic7YCwgcmV0dXJucyBgZm9vLkJhcmAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0R29vZ05hbWVzcGFjZUltcG9ydCh0c0ltcG9ydDogc3RyaW5nKTogc3RyaW5nfG51bGwge1xuICBpZiAodHNJbXBvcnQubWF0Y2goL15nb29nOi8pKSByZXR1cm4gdHNJbXBvcnQuc3Vic3RyaW5nKCdnb29nOicubGVuZ3RoKTtcbiAgcmV0dXJuIG51bGw7XG59XG5cbi8vIE1hdGNoZXMgY29tbW9uIGV4dGVuc2lvbnMgb2YgVHlwZVNjcmlwdCBpbnB1dCBmaWxlbmFtZXNcbmNvbnN0IFRTX0VYVEVOU0lPTlMgPSAvKFxcLnRzfFxcLmRcXC50c3xcXC5qc3xcXC5qc3h8XFwudHN4KSQvO1xuXG4vKipcbiAqIENvbnZlcnQgZnJvbSBpbXBsaWNpdCBgaW1wb3J0IHt9IGZyb20gJ3BrZydgIHRvIGEgZnVsbCByZXNvbHZlZCBmaWxlIG5hbWUsIGluY2x1ZGluZyBhbnkgYC9pbmRleGBcbiAqIHN1ZmZpeCBhbmQgYWxzbyByZXNvbHZpbmcgcGF0aCBtYXBwaW5ncy4gVHlwZVNjcmlwdCBhbmQgbWFueSBtb2R1bGUgbG9hZGVycyBzdXBwb3J0IHRoZVxuICogc2hvcnRoYW5kLCBidXQgYGdvb2cubW9kdWxlYCBkb2VzIG5vdCwgc28gdHNpY2tsZSBuZWVkcyB0byByZXNvbHZlIHRoZSBtb2R1bGUgbmFtZSBzaG9ydGhhbmRcbiAqIGJlZm9yZSBnZW5lcmF0aW5nIGBnb29nLm1vZHVsZWAgbmFtZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlTW9kdWxlTmFtZShcbiAgICB7b3B0aW9ucywgbW9kdWxlUmVzb2x1dGlvbkhvc3R9OlxuICAgICAgICB7b3B0aW9uczogdHMuQ29tcGlsZXJPcHRpb25zLCBtb2R1bGVSZXNvbHV0aW9uSG9zdDogdHMuTW9kdWxlUmVzb2x1dGlvbkhvc3R9LFxuICAgIHBhdGhPZkltcG9ydGluZ0ZpbGU6IHN0cmluZywgaW1wb3J0ZWQ6IHN0cmluZyk6IHN0cmluZyB7XG4gIC8vIFRoZSBzdHJhdGVneSB0YWtlbiBoZXJlIGlzIHRvIHVzZSB0cy5yZXNvbHZlTW9kdWxlTmFtZSgpIHRvIHJlc29sdmUgdGhlIGltcG9ydCB0b1xuICAvLyBhIHNwZWNpZmljIHBhdGgsIHdoaWNoIHJlc29sdmVzIGFueSAvaW5kZXggYW5kIHBhdGggbWFwcGluZ3MuXG4gIGNvbnN0IHJlc29sdmVkID1cbiAgICAgIHRzLnJlc29sdmVNb2R1bGVOYW1lKGltcG9ydGVkLCBwYXRoT2ZJbXBvcnRpbmdGaWxlLCBvcHRpb25zLCBtb2R1bGVSZXNvbHV0aW9uSG9zdCk7XG4gIGlmICghcmVzb2x2ZWQgfHwgIXJlc29sdmVkLnJlc29sdmVkTW9kdWxlKSByZXR1cm4gaW1wb3J0ZWQ7XG4gIGNvbnN0IHJlc29sdmVkTW9kdWxlID0gcmVzb2x2ZWQucmVzb2x2ZWRNb2R1bGUucmVzb2x2ZWRGaWxlTmFtZTtcblxuICAvLyBDaGVjayBpZiB0aGUgcmVzb2x1dGlvbiB3ZW50IGludG8gbm9kZV9tb2R1bGVzLlxuICAvLyBOb3RlIHRoYXQgdGhlIFJlc29sdmVkTW9kdWxlIHJldHVybmVkIGJ5IHJlc29sdmVNb2R1bGVOYW1lKCkgaGFzIGFuXG4gIC8vIGF0dHJpYnV0ZSBpc0V4dGVybmFsTGlicmFyeUltcG9ydCB0aGF0IGlzIGRvY3VtZW50ZWQgd2l0aFxuICAvLyBcIlRydWUgaWYgcmVzb2x2ZWRGaWxlTmFtZSBjb21lcyBmcm9tIG5vZGVfbW9kdWxlc1wiLCBidXQgYWN0dWFsbHkgaXQgaXMganVzdFxuICAvLyB0cnVlIGlmIHRoZSBhYnNvbHV0ZSBwYXRoIGluY2x1ZGVzIG5vZGVfbW9kdWxlcywgYW5kIGlzIGFsd2F5cyB0cnVlIHdoZW5cbiAgLy8gdHNpY2tsZSBpdHNlbGYgaXMgdW5kZXIgYSBkaXJlY3RvcnkgbmFtZWQgbm9kZV9tb2R1bGVzLlxuICBjb25zdCByZWxhdGl2ZVJlc29sdmVkID0gcGF0aC5yZWxhdGl2ZShvcHRpb25zLnJvb3REaXIgfHwgJycsIHJlc29sdmVkTW9kdWxlKTtcbiAgaWYgKHJlbGF0aXZlUmVzb2x2ZWQuaW5kZXhPZignbm9kZV9tb2R1bGVzJykgIT09IC0xKSB7XG4gICAgLy8gSW1wb3J0cyBpbnRvIG5vZGVfbW9kdWxlcyByZXNvbHZlIHRocm91Z2ggcGFja2FnZS5qc29uIGFuZCBtdXN0IGJlXG4gICAgLy8gc3BlY2lhbGx5IGhhbmRsZWQgYnkgdGhlIGxvYWRlciBhbnl3YXkuICBSZXR1cm4gdGhlIGlucHV0LlxuICAgIHJldHVybiBpbXBvcnRlZDtcbiAgfVxuXG4gIC8vIE90aGVyd2lzZSByZXR1cm4gdGhlIGZ1bGwgcmVzb2x2ZWQgZmlsZSBuYW1lLiBUaGlzIHBhdGggd2lsbCBiZSB0dXJuZWQgaW50byBhIG1vZHVsZSBuYW1lIHVzaW5nXG4gIC8vIEFubm90YXRvckhvc3QjcGF0aFRvTW9kdWxlTmFtZSwgd2hpY2ggYWxzbyB0YWtlcyBjYXJlIG9mIGJhc2VVcmwgYW5kIHJvb3REaXJzLlxuICByZXR1cm4gcmVzb2x2ZWQucmVzb2x2ZWRNb2R1bGUucmVzb2x2ZWRGaWxlTmFtZTtcbn1cblxuLyoqXG4gKiBpbXBvcnRQYXRoVG9Hb29nTmFtZXNwYWNlIGNvbnZlcnRzIGEgVFMvRVMgbW9kdWxlICcuL2ltcG9ydC9wYXRoJyBpbnRvIGEgZ29vZy5tb2R1bGUgY29tcGF0aWJsZVxuICogbmFtZXNwYWNlLCBoYW5kbGluZyByZWd1bGFyIGltcG9ydHMgYW5kIGBnb29nOmAgbmFtZXNwYWNlIGltcG9ydHMuXG4gKi9cbmZ1bmN0aW9uIGltcG9ydFBhdGhUb0dvb2dOYW1lc3BhY2UoXG4gICAgaG9zdDogR29vZ01vZHVsZVByb2Nlc3Nvckhvc3QsIGZpbGU6IHRzLlNvdXJjZUZpbGUsIHRzSW1wb3J0OiBzdHJpbmcpOiB0cy5TdHJpbmdMaXRlcmFsIHtcbiAgbGV0IG1vZE5hbWU6IHN0cmluZztcbiAgY29uc3QgbnNJbXBvcnQgPSBleHRyYWN0R29vZ05hbWVzcGFjZUltcG9ydCh0c0ltcG9ydCk7XG4gIGlmIChuc0ltcG9ydCAhPT0gbnVsbCkge1xuICAgIC8vIFRoaXMgaXMgYSBuYW1lc3BhY2UgaW1wb3J0LCBvZiB0aGUgZm9ybSBcImdvb2c6Zm9vLmJhclwiLlxuICAgIC8vIEZpeCBpdCB0byBqdXN0IFwiZm9vLmJhclwiLlxuICAgIG1vZE5hbWUgPSBuc0ltcG9ydDtcbiAgfSBlbHNlIHtcbiAgICBpZiAoaG9zdC5jb252ZXJ0SW5kZXhJbXBvcnRTaG9ydGhhbmQpIHtcbiAgICAgIHRzSW1wb3J0ID0gcmVzb2x2ZU1vZHVsZU5hbWUoaG9zdCwgZmlsZS5maWxlTmFtZSwgdHNJbXBvcnQpO1xuICAgIH1cbiAgICBtb2ROYW1lID0gaG9zdC5wYXRoVG9Nb2R1bGVOYW1lKGZpbGUuZmlsZU5hbWUsIHRzSW1wb3J0KTtcbiAgfVxuICByZXR1cm4gY3JlYXRlU2luZ2xlUXVvdGVTdHJpbmdMaXRlcmFsKG1vZE5hbWUpO1xufVxuXG4vKipcbiAqIFJlcGxhY2UgXCJtb2R1bGUuZXhwb3J0cyA9IC4uLlwiIHdpdGgganVzdCBcImV4cG9ydHMgPSAuLi5cIi4gUmV0dXJucyBudWxsIGlmIGBleHByYCBpcyBub3QgYW5cbiAqIGV4cG9ydHMgYXNzaWdubWVudC5cbiAqL1xuZnVuY3Rpb24gcmV3cml0ZU1vZHVsZUV4cG9ydHNBc3NpZ25tZW50KGV4cHI6IHRzLkV4cHJlc3Npb25TdGF0ZW1lbnQpIHtcbiAgaWYgKCF0cy5pc0JpbmFyeUV4cHJlc3Npb24oZXhwci5leHByZXNzaW9uKSkgcmV0dXJuIG51bGw7XG4gIGlmIChleHByLmV4cHJlc3Npb24ub3BlcmF0b3JUb2tlbi5raW5kICE9PSB0cy5TeW50YXhLaW5kLkVxdWFsc1Rva2VuKSByZXR1cm4gbnVsbDtcbiAgaWYgKCFpc1Byb3BlcnR5QWNjZXNzKGV4cHIuZXhwcmVzc2lvbi5sZWZ0LCAnbW9kdWxlJywgJ2V4cG9ydHMnKSkgcmV0dXJuIG51bGw7XG4gIHJldHVybiB0cy5zZXRPcmlnaW5hbE5vZGUoXG4gICAgICB0cy5zZXRUZXh0UmFuZ2UoXG4gICAgICAgICAgdHMuY3JlYXRlU3RhdGVtZW50KFxuICAgICAgICAgICAgICB0cy5jcmVhdGVBc3NpZ25tZW50KHRzLmNyZWF0ZUlkZW50aWZpZXIoJ2V4cG9ydHMnKSwgZXhwci5leHByZXNzaW9uLnJpZ2h0KSksXG4gICAgICAgICAgZXhwciksXG4gICAgICBleHByKTtcbn1cblxuLyoqXG4gKiBjb21tb25Kc1RvR29vZ21vZHVsZVRyYW5zZm9ybWVyIHJldHVybnMgYSB0cmFuc2Zvcm1lciBmYWN0b3J5IHRoYXQgY29udmVydHMgVHlwZVNjcmlwdCdzIENvbW1vbkpTXG4gKiBtb2R1bGUgZW1pdCB0byBDbG9zdXJlIENvbXBpbGVyIGNvbXBhdGlibGUgZ29vZy5tb2R1bGUgYW5kIGdvb2cucmVxdWlyZSBzdGF0ZW1lbnRzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29tbW9uSnNUb0dvb2dtb2R1bGVUcmFuc2Zvcm1lcihcbiAgICBob3N0OiBHb29nTW9kdWxlUHJvY2Vzc29ySG9zdCwgbW9kdWxlc01hbmlmZXN0OiBNb2R1bGVzTWFuaWZlc3QsIHR5cGVDaGVja2VyOiB0cy5UeXBlQ2hlY2tlcixcbiAgICBkaWFnbm9zdGljczogdHMuRGlhZ25vc3RpY1tdKTogKGNvbnRleHQ6IHRzLlRyYW5zZm9ybWF0aW9uQ29udGV4dCkgPT5cbiAgICB0cy5UcmFuc2Zvcm1lcjx0cy5Tb3VyY2VGaWxlPiB7XG4gIHJldHVybiAoY29udGV4dDogdHMuVHJhbnNmb3JtYXRpb25Db250ZXh0KTogdHMuVHJhbnNmb3JtZXI8dHMuU291cmNlRmlsZT4gPT4ge1xuICAgIC8vIFRTJyBDb21tb25KUyBwcm9jZXNzaW5nIHVzZXMgb25TdWJzdGl0dXRlTm9kZSB0bywgYXQgdGhlIHZlcnkgZW5kIG9mIHByb2Nlc3NpbmcsIHN1YnN0aXR1dGVcbiAgICAvLyBcIm1vZHVsZW5hbWUuZGVmYXVsdFwiIGZvciBkZWZhdWx0IGltcG9ydHMuIFdlIGludGVyY2VwdCB0aGUgc3Vic3RpdHV0aW9uIGhlcmUsIGNoZWNrIGlmIGl0J3MgYVxuICAgIC8vIC5kZWZhdWx0IGFjY2VzcywgdGhlbiBjaGVjayBpZiB0aGUgb3JpZ2luYWwgbm9kZSAoYW5kIHRodXMgb3JpZ2luYWwgaW1wb3J0KSB3YXMgZnJvbSBhIGdvb2c6XG4gICAgLy8gbW9kdWxlLCBhbmQgaWYgc28sIHJlcGxhY2Ugd2l0aCBqdXN0IHRoZSBtb2R1bGUgbmFtZS5cbiAgICBjb25zdCBwcmV2aW91c09uU3Vic3RpdHV0ZU5vZGUgPSBjb250ZXh0Lm9uU3Vic3RpdHV0ZU5vZGU7XG4gICAgY29udGV4dC5lbmFibGVTdWJzdGl0dXRpb24odHMuU3ludGF4S2luZC5Qcm9wZXJ0eUFjY2Vzc0V4cHJlc3Npb24pO1xuICAgIGNvbnRleHQub25TdWJzdGl0dXRlTm9kZSA9IChoaW50LCBub2RlOiB0cy5Ob2RlKTogdHMuTm9kZSA9PiB7XG4gICAgICBub2RlID0gcHJldmlvdXNPblN1YnN0aXR1dGVOb2RlKGhpbnQsIG5vZGUpO1xuICAgICAgaWYgKCF0cy5pc1Byb3BlcnR5QWNjZXNzRXhwcmVzc2lvbihub2RlKSkgcmV0dXJuIG5vZGU7XG4gICAgICBpZiAobm9kZS5uYW1lLnRleHQgIT09ICdkZWZhdWx0JykgcmV0dXJuIG5vZGU7XG4gICAgICBpZiAoIXRzLmlzSWRlbnRpZmllcihub2RlLmV4cHJlc3Npb24pKSByZXR1cm4gbm9kZTtcbiAgICAgIC8vIEZpbmQgdGhlIGltcG9ydCBkZWNsYXJhdGlvbiB0aGlzIG5vZGUgY29tZXMgZnJvbS5cbiAgICAgIC8vIFRoaXMgbWF5IGJlIHRoZSBvcmlnaW5hbCBub2RlLCBpZiB0aGUgaWRlbnRpZmllciB3YXMgdHJhbnNmb3JtZWQgZnJvbSBpdC5cbiAgICAgIGNvbnN0IG9yaWcgPSB0cy5nZXRPcmlnaW5hbE5vZGUobm9kZS5leHByZXNzaW9uKTtcbiAgICAgIGxldCBpbXBvcnRFeHBvcnREZWNsOiB0cy5JbXBvcnREZWNsYXJhdGlvbnx0cy5FeHBvcnREZWNsYXJhdGlvbjtcbiAgICAgIGlmICh0cy5pc0ltcG9ydERlY2xhcmF0aW9uKG9yaWcpIHx8IHRzLmlzRXhwb3J0RGVjbGFyYXRpb24ob3JpZykpIHtcbiAgICAgICAgaW1wb3J0RXhwb3J0RGVjbCA9IG9yaWc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBbHRlcm5hdGl2ZWx5LCB3ZSBjYW4gdHJ5IHRvIGZpbmQgdGhlIGRlY2xhcmF0aW9uIG9mIHRoZSBzeW1ib2wuIFRoaXMgb25seSB3b3JrcyBmb3JcbiAgICAgICAgLy8gdXNlci13cml0dGVuIC5kZWZhdWx0IGFjY2Vzc2VzLCB0aGUgZ2VuZXJhdGVkIG9uZXMgZG8gbm90IGhhdmUgYSBzeW1ib2wgYXNzb2NpYXRlZCBhc1xuICAgICAgICAvLyB0aGV5IGFyZSBvbmx5IHByb2R1Y2VkIGluIHRoZSBDb21tb25KUyB0cmFuc2Zvcm1hdGlvbiwgYWZ0ZXIgdHlwZSBjaGVja2luZy5cbiAgICAgICAgY29uc3Qgc3ltID0gdHlwZUNoZWNrZXIuZ2V0U3ltYm9sQXRMb2NhdGlvbihub2RlLmV4cHJlc3Npb24pO1xuICAgICAgICBpZiAoIXN5bSkgcmV0dXJuIG5vZGU7XG4gICAgICAgIGNvbnN0IGRlY2xzID0gc3ltLmdldERlY2xhcmF0aW9ucygpO1xuICAgICAgICBpZiAoIWRlY2xzIHx8ICFkZWNscy5sZW5ndGgpIHJldHVybiBub2RlO1xuICAgICAgICBjb25zdCBkZWNsID0gZGVjbHNbMF07XG4gICAgICAgIGlmIChkZWNsLnBhcmVudCAmJiBkZWNsLnBhcmVudC5wYXJlbnQgJiYgdHMuaXNJbXBvcnREZWNsYXJhdGlvbihkZWNsLnBhcmVudC5wYXJlbnQpKSB7XG4gICAgICAgICAgaW1wb3J0RXhwb3J0RGVjbCA9IGRlY2wucGFyZW50LnBhcmVudDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gSWYgdGhlIGltcG9ydCBkZWNsYXJhdGlvbidzIFVSTCBpcyBhIFwiZ29vZzouLi5cIiBzdHlsZSBuYW1lc3BhY2UsIHRoZW4gYWxsIFwiLmRlZmF1bHRcIlxuICAgICAgLy8gYWNjZXNzZXMgb24gaXQgc2hvdWxkIGJlIHJlcGxhY2VkIHdpdGggdGhlIHN5bWJvbCBpdHNlbGYuXG4gICAgICAvLyBUaGlzIGFsbG93cyByZWZlcnJpbmcgdG8gdGhlIG1vZHVsZS1sZXZlbCBleHBvcnQgb2YgYSBcImdvb2cubW9kdWxlXCIgb3IgXCJnb29nLnByb3ZpZGVcIiBhcyBpZlxuICAgICAgLy8gaXQgd2FzIGFuIEVTNiBkZWZhdWx0IGV4cG9ydC5cbiAgICAgIGlmIChleHRyYWN0R29vZ05hbWVzcGFjZUltcG9ydCgoaW1wb3J0RXhwb3J0RGVjbC5tb2R1bGVTcGVjaWZpZXIgYXMgdHMuU3RyaW5nTGl0ZXJhbCkudGV4dCkpIHtcbiAgICAgICAgLy8gU3Vic3RpdHV0ZSBcImZvby5kZWZhdWx0XCIgd2l0aCBqdXN0IFwiZm9vXCIuXG4gICAgICAgIHJldHVybiBub2RlLmV4cHJlc3Npb247XG4gICAgICB9XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIChzZjogdHMuU291cmNlRmlsZSk6IHRzLlNvdXJjZUZpbGUgPT4ge1xuICAgICAgLy8gSW4gVFMyLjksIHRyYW5zZm9ybWVycyBjYW4gcmVjZWl2ZSBCdW5kbGUgb2JqZWN0cywgd2hpY2ggdGhpcyBjb2RlIGNhbm5vdCBoYW5kbGUgKGdpdmVuXG4gICAgICAvLyB0aGF0IGEgYnVuZGxlIGJ5IGRlZmluaXRpb24gY2Fubm90IGJlIGEgZ29vZy5tb2R1bGUoKSkuIFRoZSBjYXN0IHRocm91Z2ggYW55IGlzIG5lY2Vzc2FyeVxuICAgICAgLy8gdG8gcmVtYWluIGNvbXBhdGlibGUgd2l0aCBlYXJsaWVyIFRTIHZlcnNpb25zLlxuICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueVxuICAgICAgaWYgKChzZiBhcyBhbnkpLmtpbmQgIT09IHRzLlN5bnRheEtpbmQuU291cmNlRmlsZSkgcmV0dXJuIHNmO1xuXG4gICAgICAvLyBKUyBzY3JpcHRzIChhcyBvcHBvc2VkIHRvIG1vZHVsZXMpLCBtdXN0IG5vdCBiZSByZXdyaXR0ZW4gdG9cbiAgICAgIC8vIGdvb2cubW9kdWxlcy5cbiAgICAgIGlmIChob3N0LmlzSnNUcmFuc3BpbGF0aW9uICYmICFpc01vZHVsZShzZikpIHtcbiAgICAgICAgcmV0dXJuIHNmO1xuICAgICAgfVxuXG4gICAgICBsZXQgbW9kdWxlVmFyQ291bnRlciA9IDE7XG4gICAgICAvKipcbiAgICAgICAqIENyZWF0ZXMgYSBuZXcgdW5pcXVlIHZhcmlhYmxlIHRvIGFzc2lnbiBzaWRlIGVmZmVjdCBpbXBvcnRzIGludG8uIFRoaXMgYWxsb3dzIHVzIHRvIHJlLXVzZVxuICAgICAgICogdGhlIHZhcmlhYmxlIGxhdGVyIG9uIGZvciBvdGhlciBpbXBvcnRzIG9mIHRoZSBzYW1lIG5hbWVzcGFjZS5cbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gbmV4dE1vZHVsZVZhcigpIHtcbiAgICAgICAgcmV0dXJuIGB0c2lja2xlX21vZHVsZV8ke21vZHVsZVZhckNvdW50ZXIrK31fYDtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBNYXBzIGdvb2cucmVxdWlyZSBuYW1lc3BhY2VzIHRvIHRoZSB2YXJpYWJsZSBuYW1lIHRoZXkgYXJlIGFzc2lnbmVkIGludG8uIEUuZy46XG4gICAgICAgKiAgICAgdmFyICR2YXJOYW1lID0gZ29vZy5yZXF1aXJlKCckbmFtZXNwYWNlJykpO1xuICAgICAgICovXG4gICAgICBjb25zdCBuYW1lc3BhY2VUb01vZHVsZVZhck5hbWUgPSBuZXcgTWFwPHN0cmluZywgdHMuSWRlbnRpZmllcj4oKTtcblxuICAgICAgLyoqXG4gICAgICAgKiBtYXliZUNyZWF0ZUdvb2dSZXF1aXJlIHJldHVybnMgYSBgZ29vZy5yZXF1aXJlKClgIGNhbGwgZm9yIHRoZSBnaXZlbiBDb21tb25KUyBgcmVxdWlyZWBcbiAgICAgICAqIGNhbGwuIFJldHVybnMgbnVsbCBpZiBgY2FsbGAgaXMgbm90IGEgQ29tbW9uSlMgcmVxdWlyZS5cbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gbWF5YmVDcmVhdGVHb29nUmVxdWlyZShcbiAgICAgICAgICBvcmlnaW5hbDogdHMuU3RhdGVtZW50LCBjYWxsOiB0cy5DYWxsRXhwcmVzc2lvbiwgbmV3SWRlbnQ6IHRzLklkZW50aWZpZXIpOiB0cy5TdGF0ZW1lbnR8XG4gICAgICAgICAgbnVsbCB7XG4gICAgICAgIGNvbnN0IGltcG9ydGVkVXJsID0gZXh0cmFjdFJlcXVpcmUoY2FsbCk7XG4gICAgICAgIGlmICghaW1wb3J0ZWRVcmwpIHJldHVybiBudWxsO1xuICAgICAgICBjb25zdCBpbXAgPSBpbXBvcnRQYXRoVG9Hb29nTmFtZXNwYWNlKGhvc3QsIHNmLCBpbXBvcnRlZFVybCk7XG4gICAgICAgIG1vZHVsZXNNYW5pZmVzdC5hZGRSZWZlcmVuY2VkTW9kdWxlKHNmLmZpbGVOYW1lLCBpbXAudGV4dCk7XG4gICAgICAgIGNvbnN0IGlkZW50OiB0cy5JZGVudGlmaWVyfHVuZGVmaW5lZCA9IG5hbWVzcGFjZVRvTW9kdWxlVmFyTmFtZS5nZXQoaW1wLnRleHQpO1xuICAgICAgICBsZXQgaW5pdGlhbGl6ZXI6IHRzLkV4cHJlc3Npb247XG4gICAgICAgIGlmICghaWRlbnQpIHtcbiAgICAgICAgICBuYW1lc3BhY2VUb01vZHVsZVZhck5hbWUuc2V0KGltcC50ZXh0LCBuZXdJZGVudCk7XG4gICAgICAgICAgaW5pdGlhbGl6ZXIgPSBjcmVhdGVHb29nQ2FsbCgncmVxdWlyZScsIGltcCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5pdGlhbGl6ZXIgPSBpZGVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEluIEpTIG1vZHVsZXMgaXQncyByZWNvbW1lbmRlZCB0aGF0IHVzZXJzIGdldCBhIGhhbmRsZSBvbiB0aGVcbiAgICAgICAgLy8gZ29vZyBuYW1lc3BhY2UgdmlhOlxuICAgICAgICAvL1xuICAgICAgICAvLyAgICBpbXBvcnQgKiBhcyBnb29nIGZyb20gJ2dvb2dsZTMvamF2YXNjcmlwdC9jbG9zdXJlL2dvb2cuanMnO1xuICAgICAgICAvL1xuICAgICAgICAvLyBJbiBhIGdvb2cubW9kdWxlIHdlIGp1c3Qgd2FudCB0byBhY2Nlc3MgdGhlIGdsb2JhbCBgZ29vZ2AgdmFsdWUsXG4gICAgICAgIC8vIHNvIHdlIHNraXAgZW1pdHRpbmcgdGhhdCBpbXBvcnQgYXMgYSBnb29nLnJlcXVpcmUuXG4gICAgICAgIC8vIFdlIGNoZWNrIHRoZSBnb29nIG1vZHVsZSBuYW1lIHNvIHRoYXQgd2UgYWxzbyBjYXRjaCByZWxhdGl2ZSBpbXBvcnRzLlxuICAgICAgICBpZiAobmV3SWRlbnQuZXNjYXBlZFRleHQgPT09ICdnb29nJyAmJiBpbXAudGV4dCA9PT0gJ2dvb2dsZTMuamF2YXNjcmlwdC5jbG9zdXJlLmdvb2cnKSB7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZU5vdEVtaXR0ZWRTdGF0ZW1lbnRXaXRoQ29tbWVudHMoc2YsIG9yaWdpbmFsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHZhckRlY2wgPSB0cy5jcmVhdGVWYXJpYWJsZURlY2xhcmF0aW9uKG5ld0lkZW50LCAvKiB0eXBlICovIHVuZGVmaW5lZCwgaW5pdGlhbGl6ZXIpO1xuICAgICAgICBjb25zdCBuZXdTdG10ID0gdHMuY3JlYXRlVmFyaWFibGVTdGF0ZW1lbnQoXG4gICAgICAgICAgICAvKiBtb2RpZmllcnMgKi8gdW5kZWZpbmVkLFxuICAgICAgICAgICAgdHMuY3JlYXRlVmFyaWFibGVEZWNsYXJhdGlvbkxpc3QoXG4gICAgICAgICAgICAgICAgW3ZhckRlY2xdLFxuICAgICAgICAgICAgICAgIC8vIFVzZSAnY29uc3QnIGluIEVTNiBtb2RlIHNvIENsb3N1cmUgcHJvcGVybHkgZm9yd2FyZHMgdHlwZSBhbGlhc2VzLlxuICAgICAgICAgICAgICAgIGhvc3QuZXM1TW9kZSA/IHVuZGVmaW5lZCA6IHRzLk5vZGVGbGFncy5Db25zdCkpO1xuICAgICAgICByZXR1cm4gdHMuc2V0T3JpZ2luYWxOb2RlKHRzLnNldFRleHRSYW5nZShuZXdTdG10LCBvcmlnaW5hbCksIG9yaWdpbmFsKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZXdyaXRlIGdvb2cuZGVjbGFyZU1vZHVsZUlkIHRvIHNvbWV0aGluZyB0aGF0IHdvcmtzIGluIGEgZ29vZy5tb2R1bGUuXG4gICAgICAgKlxuICAgICAgICogZ29vZy5kZWNsYXJlTW9kdWxlSWQgZXhwb3NlcyBhIEpTIG1vZHVsZSBhcyBhIGdvb2cubW9kdWxlLiBBZnRlciB3ZVxuICAgICAgICogY29udmVydCB0aGUgSlMgbW9kdWxlIHRvIGEgZ29vZy5tb2R1bGUsIHdoYXQgd2UgcmVhbGx5IHdhbnQgaXMgdG9cbiAgICAgICAqIGV4cG9zZSB0aGUgY3VycmVudCBnb29nLm1vZHVsZSBhdCB0d28gZGlmZmVyZW50IG1vZHVsZSBpZHMuIFRoaXMgaXNuJ3RcbiAgICAgICAqIHBvc3NpYmxlIHdpdGggdGhlIHB1YmxpYyBBUElzLCBidXQgd2UgY2FuIG1ha2UgaXQgd29yayBhdCBydW50aW1lXG4gICAgICAgKiBieSB3cml0aW5nIGEgcmVjb3JkIHRvIGdvb2cubG9hZGVkTW9kdWxlc18uXG4gICAgICAgKlxuICAgICAgICogVGhpcyBvbmx5IHdvcmtzIGF0IHJ1bnRpbWUsIGFuZCB3b3VsZCBmYWlsIGlmIGNvbXBpbGVkIGJ5IGNsb3N1cmVcbiAgICAgICAqIGNvbXBpbGVyLCBidXQgdGhhdCdzIG9rIGJlY2F1c2Ugd2Ugb25seSB0cmFuc3BpbGUgSlMgaW4gZGV2ZWxvcG1lbnRcbiAgICAgICAqIG1vZGUuXG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIG1heWJlUmV3cml0ZURlY2xhcmVNb2R1bGVJZChcbiAgICAgICAgICBvcmlnaW5hbDogdHMuU3RhdGVtZW50LCBjYWxsOiB0cy5DYWxsRXhwcmVzc2lvbik6IHRzLlN0YXRlbWVudHxudWxsIHtcbiAgICAgICAgLy8gVmVyaWZ5IHRoYXQgdGhlIGNhbGwgaXMgYSBjYWxsIHRvIGdvb2cuZGVjbGFyZU1vZHVsZUlkKC4uLikuXG4gICAgICAgIGlmICghdHMuaXNQcm9wZXJ0eUFjY2Vzc0V4cHJlc3Npb24oY2FsbC5leHByZXNzaW9uKSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByb3BBY2Nlc3MgPSBjYWxsLmV4cHJlc3Npb247XG4gICAgICAgIGlmIChwcm9wQWNjZXNzLm5hbWUuZXNjYXBlZFRleHQgIT09ICdkZWNsYXJlTW9kdWxlSWQnKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0cy5pc0lkZW50aWZpZXIocHJvcEFjY2Vzcy5leHByZXNzaW9uKSB8fFxuICAgICAgICAgICAgcHJvcEFjY2Vzcy5leHByZXNzaW9uLmVzY2FwZWRUZXh0ICE9PSAnZ29vZycpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFZlcmlmeSB0aGUgY2FsbCB0YWtlcyBhIHNpbmdsZSBzdHJpbmcgYXJndW1lbnQgYW5kIGdyYWIgaXQuXG4gICAgICAgIGlmIChjYWxsLmFyZ3VtZW50cy5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcmcgPSBjYWxsLmFyZ3VtZW50c1swXTtcbiAgICAgICAgaWYgKCF0cy5pc1N0cmluZ0xpdGVyYWwoYXJnKSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1vZHVsZUlkID0gYXJnLnRleHQ7XG4gICAgICAgIC8vIHJlcGxhY2UgZ29vZy5kZWNsYXJlTW9kdWxlSWRbJ2Zvby5iYXInXSB3aXRoOlxuICAgICAgICAvLyBnb29nLmxvYWRlZE1vZHVsZXNfWydmb28uYmFyJ10gPSB7XG4gICAgICAgIC8vICAgZXhwb3J0czogZXhwb3J0cyxcbiAgICAgICAgLy8gICB0eXBlOiBnb29nLk1vZHVsZVR5cGUuR09PRyxcbiAgICAgICAgLy8gICBtb2R1bGVJZDogJ2Zvby5iYXInXG4gICAgICAgIC8vIH07XG4gICAgICAgIC8vXG4gICAgICAgIC8vIEZvciBtb3JlIGluZm8sIHNlZSBgZ29vZy5sb2FkTW9kdWxlYCBpblxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZ29vZ2xlL2Nsb3N1cmUtbGlicmFyeS9ibG9iL21hc3Rlci9jbG9zdXJlL2dvb2cvYmFzZS5qc1xuICAgICAgICBjb25zdCBuZXdTdG10ID0gdHMuY3JlYXRlU3RhdGVtZW50KHRzLmNyZWF0ZUFzc2lnbm1lbnQoXG4gICAgICAgICAgICB0cy5jcmVhdGVFbGVtZW50QWNjZXNzKFxuICAgICAgICAgICAgICAgIHRzLmNyZWF0ZVByb3BlcnR5QWNjZXNzKFxuICAgICAgICAgICAgICAgICAgICB0cy5jcmVhdGVJZGVudGlmaWVyKCdnb29nJyksIHRzLmNyZWF0ZUlkZW50aWZpZXIoJ2xvYWRlZE1vZHVsZXNfJykpLFxuICAgICAgICAgICAgICAgIGNyZWF0ZVNpbmdsZVF1b3RlU3RyaW5nTGl0ZXJhbChtb2R1bGVJZCkpLFxuICAgICAgICAgICAgdHMuY3JlYXRlT2JqZWN0TGl0ZXJhbChbXG4gICAgICAgICAgICAgIHRzLmNyZWF0ZVByb3BlcnR5QXNzaWdubWVudCgnZXhwb3J0cycsIHRzLmNyZWF0ZUlkZW50aWZpZXIoJ2V4cG9ydHMnKSksXG4gICAgICAgICAgICAgIHRzLmNyZWF0ZVByb3BlcnR5QXNzaWdubWVudChcbiAgICAgICAgICAgICAgICAgICd0eXBlJyxcbiAgICAgICAgICAgICAgICAgIHRzLmNyZWF0ZVByb3BlcnR5QWNjZXNzKFxuICAgICAgICAgICAgICAgICAgICAgIHRzLmNyZWF0ZVByb3BlcnR5QWNjZXNzKFxuICAgICAgICAgICAgICAgICAgICAgICAgICB0cy5jcmVhdGVJZGVudGlmaWVyKCdnb29nJyksIHRzLmNyZWF0ZUlkZW50aWZpZXIoJ01vZHVsZVR5cGUnKSksXG4gICAgICAgICAgICAgICAgICAgICAgdHMuY3JlYXRlSWRlbnRpZmllcignR09PRycpKSksXG4gICAgICAgICAgICAgIHRzLmNyZWF0ZVByb3BlcnR5QXNzaWdubWVudCgnbW9kdWxlSWQnLCBjcmVhdGVTaW5nbGVRdW90ZVN0cmluZ0xpdGVyYWwobW9kdWxlSWQpKSxcbiAgICAgICAgICAgIF0pKSk7XG4gICAgICAgIHJldHVybiB0cy5zZXRPcmlnaW5hbE5vZGUodHMuc2V0VGV4dFJhbmdlKG5ld1N0bXQsIG9yaWdpbmFsKSwgb3JpZ2luYWwpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIG1heWJlUmV3cml0ZVJlcXVpcmVUc2xpYiByZXdyaXRlcyBhIHJlcXVpcmUoJ3RzbGliJykgY2FsbHMgdG8gZ29vZy5yZXF1aXJlKCd0c2xpYicpLiBJdFxuICAgICAgICogcmV0dXJucyB0aGUgaW5wdXQgc3RhdGVtZW50IHVudG91Y2hlZCBpZiBpdCBkb2VzIG5vdCBtYXRjaC5cbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gbWF5YmVSZXdyaXRlUmVxdWlyZVRzbGliKHN0bXQ6IHRzLlN0YXRlbWVudCk6IHRzLlN0YXRlbWVudHxudWxsIHtcbiAgICAgICAgaWYgKCF0cy5pc0V4cHJlc3Npb25TdGF0ZW1lbnQoc3RtdCkpIHJldHVybiBudWxsO1xuICAgICAgICBpZiAoIXRzLmlzQ2FsbEV4cHJlc3Npb24oc3RtdC5leHByZXNzaW9uKSkgcmV0dXJuIG51bGw7XG4gICAgICAgIGNvbnN0IGNhbGxFeHByID0gc3RtdC5leHByZXNzaW9uO1xuICAgICAgICBpZiAoIXRzLmlzSWRlbnRpZmllcihjYWxsRXhwci5leHByZXNzaW9uKSB8fCBjYWxsRXhwci5leHByZXNzaW9uLnRleHQgIT09ICdyZXF1aXJlJykge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYWxsRXhwci5hcmd1bWVudHMubGVuZ3RoICE9PSAxKSByZXR1cm4gc3RtdDtcbiAgICAgICAgY29uc3QgYXJnID0gY2FsbEV4cHIuYXJndW1lbnRzWzBdO1xuICAgICAgICBpZiAoIXRzLmlzU3RyaW5nTGl0ZXJhbChhcmcpIHx8IGFyZy50ZXh0ICE9PSAndHNsaWInKSByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRzLnNldE9yaWdpbmFsTm9kZShcbiAgICAgICAgICAgIHRzLnNldFRleHRSYW5nZSh0cy5jcmVhdGVTdGF0ZW1lbnQoY3JlYXRlR29vZ0NhbGwoJ3JlcXVpcmUnLCBhcmcpKSwgc3RtdCksIHN0bXQpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIHZpc2l0VG9wTGV2ZWxTdGF0ZW1lbnQgaW1wbGVtZW50cyB0aGUgbWFpbiBDb21tb25KUyB0byBnb29nLm1vZHVsZSBjb252ZXJzaW9uLiBJdCB2aXNpdHMgYVxuICAgICAgICogU291cmNlRmlsZSBsZXZlbCBzdGF0ZW1lbnQgYW5kIGFkZHMgYSAocG9zc2libHkpIHRyYW5zZm9ybWVkIHJlcHJlc2VudGF0aW9uIG9mIGl0IGludG9cbiAgICAgICAqIHN0YXRlbWVudHMuIEl0IGFkZHMgYXQgbGVhc3Qgb25lIG5vZGUgcGVyIHN0YXRlbWVudCB0byBzdGF0ZW1lbnRzLlxuICAgICAgICpcbiAgICAgICAqIHZpc2l0VG9wTGV2ZWxTdGF0ZW1lbnQ6XG4gICAgICAgKiAtIGNvbnZlcnRzIHJlcXVpcmUoKSBjYWxscyB0byBnb29nLnJlcXVpcmUoKSBjYWxscywgd2l0aCBvciB3L28gdmFyIGFzc2lnbm1lbnRcbiAgICAgICAqIC0gcmVtb3ZlcyBcInVzZSBzdHJpY3RcIjsgYW5kIFwiT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fZXNNb2R1bGUpXCIgc3RhdGVtZW50c1xuICAgICAgICogLSBjb252ZXJ0cyBtb2R1bGUuZXhwb3J0cyBhc3NpZ25tZW50cyB0byBqdXN0IGV4cG9ydHMgYXNzaWdubWVudHNcbiAgICAgICAqIC0gc3BsaXRzIF9fZXhwb3J0U3RhcigpIGNhbGxzIGludG8gcmVxdWlyZSBhbmQgZXhwb3J0ICh0aGlzIG5lZWRzIHR3byBzdGF0ZW1lbnRzKVxuICAgICAgICogLSBtYWtlcyBzdXJlIHRvIG9ubHkgaW1wb3J0IGVhY2ggbmFtZXNwYWNlIGV4YWN0bHkgb25jZSwgYW5kIHVzZSB2YXJpYWJsZXMgbGF0ZXIgb25cbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gdmlzaXRUb3BMZXZlbFN0YXRlbWVudChcbiAgICAgICAgICBzdGF0ZW1lbnRzOiB0cy5TdGF0ZW1lbnRbXSwgc2Y6IHRzLlNvdXJjZUZpbGUsIG5vZGU6IHRzLlN0YXRlbWVudCk6IHZvaWQge1xuICAgICAgICAvLyBIYW5kbGUgZWFjaCBwYXJ0aWN1bGFyIGNhc2UgYnkgYWRkaW5nIG5vZGUgdG8gc3RhdGVtZW50cywgdGhlbiByZXR1cm4uXG4gICAgICAgIC8vIEZvciB1bmhhbmRsZWQgY2FzZXMsIGJyZWFrIHRvIGp1bXAgdG8gdGhlIGRlZmF1bHQgaGFuZGxpbmcgYmVsb3cuXG5cbiAgICAgICAgLy8gSW4gSlMgdHJhbnNwaWxhdGlvbiBtb2RlLCBhbHdheXMgcmV3cml0ZSBgcmVxdWlyZSgndHNsaWInKWAgdG9cbiAgICAgICAgLy8gZ29vZy5yZXF1aXJlKCd0c2xpYicpLCBpZ25vcmluZyBub3JtYWwgbW9kdWxlIHJlc29sdXRpb24uXG4gICAgICAgIGlmIChob3N0LmlzSnNUcmFuc3BpbGF0aW9uKSB7XG4gICAgICAgICAgY29uc3QgcmV3cml0dGVuVHNMaWIgPSBtYXliZVJld3JpdGVSZXF1aXJlVHNsaWIobm9kZSk7XG4gICAgICAgICAgaWYgKHJld3JpdHRlblRzTGliKSB7XG4gICAgICAgICAgICBzdGF0ZW1lbnRzLnB1c2gocmV3cml0dGVuVHNMaWIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAobm9kZS5raW5kKSB7XG4gICAgICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLkV4cHJlc3Npb25TdGF0ZW1lbnQ6IHtcbiAgICAgICAgICAgIGNvbnN0IGV4cHJTdG10ID0gbm9kZSBhcyB0cy5FeHByZXNzaW9uU3RhdGVtZW50O1xuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIFwidXNlIHN0cmljdFwiIGFuZCBjZXJ0YWluIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSBhbmQgc2tpcCBpdCBpZiBuZWNlc3NhcnkuXG4gICAgICAgICAgICBpZiAoaXNVc2VTdHJpY3QoZXhwclN0bXQpIHx8IGlzRXNNb2R1bGVQcm9wZXJ0eShleHByU3RtdCkpIHtcbiAgICAgICAgICAgICAgc3RtdHMucHVzaChjcmVhdGVOb3RFbWl0dGVkU3RhdGVtZW50V2l0aENvbW1lbnRzKHNmLCBleHByU3RtdCkpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDaGVjayBmb3I6XG4gICAgICAgICAgICAvLyAgIG1vZHVsZS5leHBvcnRzID0gLi4uO1xuICAgICAgICAgICAgY29uc3QgbW9kRXhwb3J0cyA9IHJld3JpdGVNb2R1bGVFeHBvcnRzQXNzaWdubWVudChleHByU3RtdCk7XG4gICAgICAgICAgICBpZiAobW9kRXhwb3J0cykge1xuICAgICAgICAgICAgICBzdG10cy5wdXNoKG1vZEV4cG9ydHMpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDaGVjayBmb3I6XG4gICAgICAgICAgICAvLyAgIFwicmVxdWlyZSgnZm9vJyk7XCIgKGEgcmVxdWlyZSBmb3IgaXRzIHNpZGUgZWZmZWN0cylcbiAgICAgICAgICAgIGNvbnN0IGV4cHIgPSBleHByU3RtdC5leHByZXNzaW9uO1xuICAgICAgICAgICAgaWYgKCF0cy5pc0NhbGxFeHByZXNzaW9uKGV4cHIpKSBicmVhaztcbiAgICAgICAgICAgIGxldCBjYWxsRXhwciA9IGV4cHI7XG4gICAgICAgICAgICBjb25zdCBkZWNsYXJlZE1vZHVsZUlkID0gbWF5YmVSZXdyaXRlRGVjbGFyZU1vZHVsZUlkKGV4cHJTdG10LCBjYWxsRXhwcik7XG4gICAgICAgICAgICBpZiAoZGVjbGFyZWRNb2R1bGVJZCkge1xuICAgICAgICAgICAgICBzdGF0ZW1lbnRzLnB1c2goZGVjbGFyZWRNb2R1bGVJZCk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEhhbmRsZSBleHBvcnQgKiBpbiBFUzUgbW9kZSAoaW4gRVM2IG1vZGUsIGV4cG9ydCAqIGlzIGRlcmVmZXJlbmNlZCBhbHJlYWR5KS5cbiAgICAgICAgICAgIC8vIGV4cG9ydCAqIGNyZWF0ZXMgZWl0aGVyIGEgcHVyZSB0b3AtbGV2ZWwgJ19fZXhwb3J0KHJlcXVpcmUoLi4uKSknIG9yIHRoZSBpbXBvcnRlZFxuICAgICAgICAgICAgLy8gdmVyc2lvbiwgJ3RzbGliLl9fZXhwb3J0U3RhcihyZXF1aXJlKC4uLikpJy4gVGhlIGltcG9ydGVkIHZlcnNpb24gaXMgb25seSBzdWJzdGl0dXRlZFxuICAgICAgICAgICAgLy8gbGF0ZXIgb24gdGhvdWdoLCBzbyBhcHBlYXJzIGFzIGEgcGxhaW4gXCJfX2V4cG9ydFN0YXJcIiBvbiB0aGUgdG9wIGxldmVsIGhlcmUuXG4gICAgICAgICAgICBjb25zdCBpc0V4cG9ydFN0YXIgPVxuICAgICAgICAgICAgICAgICh0cy5pc0lkZW50aWZpZXIoZXhwci5leHByZXNzaW9uKSAmJiBleHByLmV4cHJlc3Npb24udGV4dCA9PT0gJ19fZXhwb3J0U3RhcicpIHx8XG4gICAgICAgICAgICAgICAgKHRzLmlzSWRlbnRpZmllcihleHByLmV4cHJlc3Npb24pICYmIGV4cHIuZXhwcmVzc2lvbi50ZXh0ID09PSAnX19leHBvcnQnKTtcbiAgICAgICAgICAgIGlmIChpc0V4cG9ydFN0YXIpIGNhbGxFeHByID0gZXhwci5hcmd1bWVudHNbMF0gYXMgdHMuQ2FsbEV4cHJlc3Npb247XG4gICAgICAgICAgICBjb25zdCBpZGVudCA9IHRzLmNyZWF0ZUlkZW50aWZpZXIobmV4dE1vZHVsZVZhcigpKTtcbiAgICAgICAgICAgIGNvbnN0IHJlcXVpcmUgPSBtYXliZUNyZWF0ZUdvb2dSZXF1aXJlKGV4cHJTdG10LCBjYWxsRXhwciwgaWRlbnQpO1xuICAgICAgICAgICAgaWYgKCFyZXF1aXJlKSBicmVhaztcbiAgICAgICAgICAgIHN0YXRlbWVudHMucHVzaChyZXF1aXJlKTtcbiAgICAgICAgICAgIC8vIElmIHRoaXMgaXMgYW4gZXhwb3J0IHN0YXIsIHNwbGl0IGl0IHVwIGludG8gdGhlIGltcG9ydCAoY3JlYXRlZCBieSB0aGUgbWF5YmUgY2FsbFxuICAgICAgICAgICAgLy8gYWJvdmUpLCBhbmQgdGhlIGV4cG9ydCBvcGVyYXRpb24uIFRoaXMgYXZvaWRzIGEgQ2xvc3VyZSBjb21wbGFpbnQgYWJvdXQgbm9uLXRvcC1sZXZlbFxuICAgICAgICAgICAgLy8gcmVxdWlyZXMuXG4gICAgICAgICAgICBpZiAoaXNFeHBvcnRTdGFyKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGFyZ3M6IHRzLkV4cHJlc3Npb25bXSA9IFtpZGVudF07XG4gICAgICAgICAgICAgIGlmIChleHByLmFyZ3VtZW50cy5sZW5ndGggPiAxKSBhcmdzLnB1c2goZXhwci5hcmd1bWVudHNbMV0pO1xuICAgICAgICAgICAgICBzdGF0ZW1lbnRzLnB1c2godHMuY3JlYXRlU3RhdGVtZW50KHRzLmNyZWF0ZUNhbGwoZXhwci5leHByZXNzaW9uLCB1bmRlZmluZWQsIGFyZ3MpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgdHMuU3ludGF4S2luZC5WYXJpYWJsZVN0YXRlbWVudDoge1xuICAgICAgICAgICAgLy8gSXQncyBwb3NzaWJseSBvZiB0aGUgZm9ybSBcInZhciB4ID0gcmVxdWlyZSguLi4pO1wiLlxuICAgICAgICAgICAgY29uc3QgdmFyU3RtdCA9IG5vZGUgYXMgdHMuVmFyaWFibGVTdGF0ZW1lbnQ7XG4gICAgICAgICAgICAvLyBWZXJpZnkgaXQncyBhIHNpbmdsZSBkZWNsIChhbmQgbm90IFwidmFyIHggPSAuLi4sIHkgPSAuLi47XCIpLlxuICAgICAgICAgICAgaWYgKHZhclN0bXQuZGVjbGFyYXRpb25MaXN0LmRlY2xhcmF0aW9ucy5sZW5ndGggIT09IDEpIGJyZWFrO1xuICAgICAgICAgICAgY29uc3QgZGVjbCA9IHZhclN0bXQuZGVjbGFyYXRpb25MaXN0LmRlY2xhcmF0aW9uc1swXTtcblxuICAgICAgICAgICAgLy8gR3JhYiB0aGUgdmFyaWFibGUgbmFtZSAoYXZvaWRpbmcgdGhpbmdzIGxpa2UgZGVzdHJ1Y3R1cmluZyBiaW5kcykuXG4gICAgICAgICAgICBpZiAoZGVjbC5uYW1lLmtpbmQgIT09IHRzLlN5bnRheEtpbmQuSWRlbnRpZmllcikgYnJlYWs7XG4gICAgICAgICAgICBpZiAoIWRlY2wuaW5pdGlhbGl6ZXIgfHwgIXRzLmlzQ2FsbEV4cHJlc3Npb24oZGVjbC5pbml0aWFsaXplcikpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXF1aXJlID0gbWF5YmVDcmVhdGVHb29nUmVxdWlyZSh2YXJTdG10LCBkZWNsLmluaXRpYWxpemVyLCBkZWNsLm5hbWUpO1xuICAgICAgICAgICAgaWYgKCFyZXF1aXJlKSBicmVhaztcbiAgICAgICAgICAgIHN0YXRlbWVudHMucHVzaChyZXF1aXJlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlbWVudHMucHVzaChub2RlKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbW9kdWxlTmFtZSA9IGhvc3QucGF0aFRvTW9kdWxlTmFtZSgnJywgc2YuZmlsZU5hbWUpO1xuICAgICAgLy8gUmVnaXN0ZXIgdGhlIG5hbWVzcGFjZSB0aGlzIGZpbGUgcHJvdmlkZXMuXG4gICAgICBtb2R1bGVzTWFuaWZlc3QuYWRkTW9kdWxlKHNmLmZpbGVOYW1lLCBtb2R1bGVOYW1lKTtcblxuICAgICAgLy8gQ29udmVydCBlYWNoIHRvcCBsZXZlbCBzdGF0ZW1lbnQgdG8gZ29vZy5tb2R1bGUuXG4gICAgICBjb25zdCBzdG10czogdHMuU3RhdGVtZW50W10gPSBbXTtcbiAgICAgIGZvciAoY29uc3Qgc3RtdCBvZiBzZi5zdGF0ZW1lbnRzKSB7XG4gICAgICAgIHZpc2l0VG9wTGV2ZWxTdGF0ZW1lbnQoc3RtdHMsIHNmLCBzdG10KTtcbiAgICAgIH1cblxuICAgICAgLy8gQWRkaXRpb25hbCBzdGF0ZW1lbnRzIHRoYXQgd2lsbCBiZSBwcmVwZW5kZWQgKGdvb2cubW9kdWxlIGNhbGwgZXRjKS5cbiAgICAgIGNvbnN0IGhlYWRlclN0bXRzOiB0cy5TdGF0ZW1lbnRbXSA9IFtdO1xuXG4gICAgICAvLyBFbWl0OiBnb29nLm1vZHVsZSgnbW9kdWxlTmFtZScpO1xuICAgICAgY29uc3QgZ29vZ01vZHVsZSA9XG4gICAgICAgICAgdHMuY3JlYXRlU3RhdGVtZW50KGNyZWF0ZUdvb2dDYWxsKCdtb2R1bGUnLCBjcmVhdGVTaW5nbGVRdW90ZVN0cmluZ0xpdGVyYWwobW9kdWxlTmFtZSkpKTtcbiAgICAgIGhlYWRlclN0bXRzLnB1c2goZ29vZ01vZHVsZSk7XG5cbiAgICAgIC8vIEFsbG93IGNvZGUgdG8gdXNlIGBtb2R1bGUuaWRgIHRvIGRpc2NvdmVyIGl0cyBtb2R1bGUgVVJMLCBlLmcuIHRvIHJlc29sdmUgYSB0ZW1wbGF0ZSBVUkxcbiAgICAgIC8vIGFnYWluc3QuIFVzZXMgJ3ZhcicsIGFzIHRoaXMgY29kZSBpcyBpbnNlcnRlZCBpbiBFUzYgYW5kIEVTNSBtb2Rlcy4gVGhlIGZvbGxvd2luZyBwYXR0ZXJuXG4gICAgICAvLyBlbnN1cmVzIGNsb3N1cmUgZG9lc24ndCB0aHJvdyBhbiBlcnJvciBpbiBhZHZhbmNlZCBvcHRpbWl6YXRpb25zIG1vZGUuXG4gICAgICAvLyB2YXIgbW9kdWxlID0gbW9kdWxlIHx8IHtpZDogJ3BhdGgvdG8vbW9kdWxlLnRzJ307XG4gICAgICBjb25zdCBtb2R1bGVJZCA9IGhvc3QuZmlsZU5hbWVUb01vZHVsZUlkKHNmLmZpbGVOYW1lKTtcbiAgICAgIGNvbnN0IG1vZHVsZVZhckluaXRpYWxpemVyID0gdHMuY3JlYXRlQmluYXJ5KFxuICAgICAgICAgIHRzLmNyZWF0ZUlkZW50aWZpZXIoJ21vZHVsZScpLCB0cy5TeW50YXhLaW5kLkJhckJhclRva2VuLFxuICAgICAgICAgIHRzLmNyZWF0ZU9iamVjdExpdGVyYWwoXG4gICAgICAgICAgICAgIFt0cy5jcmVhdGVQcm9wZXJ0eUFzc2lnbm1lbnQoJ2lkJywgY3JlYXRlU2luZ2xlUXVvdGVTdHJpbmdMaXRlcmFsKG1vZHVsZUlkKSldKSk7XG4gICAgICBjb25zdCBtb2RBc3NpZ24gPSB0cy5jcmVhdGVWYXJpYWJsZVN0YXRlbWVudChcbiAgICAgICAgICAvKiBtb2RpZmllcnMgKi8gdW5kZWZpbmVkLCB0cy5jcmVhdGVWYXJpYWJsZURlY2xhcmF0aW9uTGlzdChbdHMuY3JlYXRlVmFyaWFibGVEZWNsYXJhdGlvbihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ21vZHVsZScsIC8qIHR5cGUgKi8gdW5kZWZpbmVkLCBtb2R1bGVWYXJJbml0aWFsaXplcildKSk7XG4gICAgICBoZWFkZXJTdG10cy5wdXNoKG1vZEFzc2lnbik7XG5cbiAgICAgIGlmICghaG9zdC5lczVNb2RlKSB7XG4gICAgICAgIC8vIFRoZSBtb2R1bGU9bW9kdWxlIGFzc2lnbm1lbnQgc3VwcHJlc3NlcyBhbiB1bnVzZWQgdmFyaWFibGUgd2FybmluZyB3aGljaCBtYXkgdHJpZ2dlclxuICAgICAgICAvLyBkZXBlbmRpbmcgb24gdGhlIHByb2plY3QncyBjb21waWxhdGlvbiBmbGFncy5cbiAgICAgICAgaGVhZGVyU3RtdHMucHVzaCh0cy5jcmVhdGVTdGF0ZW1lbnQoXG4gICAgICAgICAgICB0cy5jcmVhdGVBc3NpZ25tZW50KHRzLmNyZWF0ZUlkZW50aWZpZXIoJ21vZHVsZScpLCB0cy5jcmVhdGVJZGVudGlmaWVyKCdtb2R1bGUnKSkpKTtcblxuICAgICAgICAvLyBUaGUgYGV4cG9ydHMgPSB7fWAgc2VydmVzIGFzIGEgZGVmYXVsdCBleHBvcnQgdG8gZGlzYWJsZSBDbG9zdXJlIENvbXBpbGVyJ3MgZXJyb3JcbiAgICAgICAgLy8gY2hlY2tpbmdcbiAgICAgICAgLy8gZm9yIG11dGFibGUgZXhwb3J0cy4gVGhhdCdzIE9LIGJlY2F1c2UgVFMgY29tcGlsZXIgbWFrZXMgc3VyZSB0aGF0IGNvbnN1bWluZyBjb2RlIGFsd2F5c1xuICAgICAgICAvLyBhY2Nlc3NlcyBleHBvcnRzIHRocm91Z2ggdGhlIG1vZHVsZSBvYmplY3QsIHNvIG11dGFibGUgZXhwb3J0cyB3b3JrLlxuICAgICAgICAvLyBJdCBpcyBvbmx5IGluc2VydGVkIGluIEVTNiBiZWNhdXNlIHdlIHN0cmlwIGAuZGVmYXVsdGAgYWNjZXNzZXMgaW4gRVM1IG1vZGUsIHdoaWNoIGJyZWFrc1xuICAgICAgICAvLyB3aGVuIGFzc2lnbmluZyBhbiBgZXhwb3J0cyA9IHt9YCBvYmplY3QgYW5kIHRoZW4gbGF0ZXIgYWNjZXNzaW5nIGl0LlxuICAgICAgICAvLyBIb3dldmVyIENsb3N1cmUgYmFpbHMgaWYgY29kZSBsYXRlciBvbiBhc3NpZ25zIGludG8gZXhwb3J0cyBkaXJlY3RseSwgYXMgd2UgZG8gaWYgd2UgaGF2ZVxuICAgICAgICAvLyBhbiBcImV4cG9ydHMgPSBcIiBibG9jaywgc28gc2tpcCBlbWl0IGlmIHRoYXQncyB0aGUgY2FzZS5cbiAgICAgICAgaWYgKCFzZi5zdGF0ZW1lbnRzLmZpbmQoXG4gICAgICAgICAgICAgICAgcyA9PiB0cy5pc0V4cHJlc3Npb25TdGF0ZW1lbnQocykgJiZcbiAgICAgICAgICAgICAgICAgICAgKGlzTW9kdWxlRXhwb3J0c0Fzc2lnbm1lbnQocykgfHwgaXNFeHBvcnRzQXNzaWdubWVudChzKSkpKSB7XG4gICAgICAgICAgaGVhZGVyU3RtdHMucHVzaCh0cy5jcmVhdGVTdGF0ZW1lbnQoXG4gICAgICAgICAgICAgIHRzLmNyZWF0ZUFzc2lnbm1lbnQodHMuY3JlYXRlSWRlbnRpZmllcignZXhwb3J0cycpLCB0cy5jcmVhdGVPYmplY3RMaXRlcmFsKCkpKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gSW5zZXJ0IGdvb2cubW9kdWxlKCkgZXRjIGFmdGVyIGFueSBsZWFkaW5nIGNvbW1lbnRzIGluIHRoZSBzb3VyY2UgZmlsZS4gVGhlIGNvbW1lbnRzIGhhdmVcbiAgICAgIC8vIGJlZW4gY29udmVydGVkIHRvIE5vdEVtaXR0ZWRTdGF0ZW1lbnRzIGJ5IHRyYW5zZm9ybWVyX3V0aWwsIHdoaWNoIHRoaXMgZGVwZW5kcyBvbi5cbiAgICAgIGNvbnN0IGluc2VydGlvbklkeCA9IHN0bXRzLmZpbmRJbmRleChzID0+IHMua2luZCAhPT0gdHMuU3ludGF4S2luZC5Ob3RFbWl0dGVkU3RhdGVtZW50KTtcbiAgICAgIGlmIChpbnNlcnRpb25JZHggPT09IC0xKSB7XG4gICAgICAgIHN0bXRzLnB1c2goLi4uaGVhZGVyU3RtdHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RtdHMuc3BsaWNlKGluc2VydGlvbklkeCwgMCwgLi4uaGVhZGVyU3RtdHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHMudXBkYXRlU291cmNlRmlsZU5vZGUoc2YsIHRzLnNldFRleHRSYW5nZSh0cy5jcmVhdGVOb2RlQXJyYXkoc3RtdHMpLCBzZi5zdGF0ZW1lbnRzKSk7XG4gICAgfTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gaXNNb2R1bGUoc291cmNlRmlsZTogdHMuU291cmNlRmlsZSk6IGJvb2xlYW4ge1xuICBpbnRlcmZhY2UgSW50ZXJuYWxTb3VyY2VGaWxlIGV4dGVuZHMgdHMuU291cmNlRmlsZSB7XG4gICAgLy8gQW4gaW50ZXJuYWwgcHJvcGVydHkgdGhhdCB3ZSB1c2UgaGVyZSB0byBjaGVjayB3aGV0aGVyIGEgZmlsZSBpc1xuICAgIC8vIHN5bnRhY3RpY2FsbHkgYSBtb2R1bGUgb3IgYSBzY3JpcHQuXG4gICAgZXh0ZXJuYWxNb2R1bGVJbmRpY2F0b3I/OiB0cy5Ob2RlO1xuICB9XG4gIHJldHVybiBCb29sZWFuKChzb3VyY2VGaWxlIGFzIEludGVybmFsU291cmNlRmlsZSkuZXh0ZXJuYWxNb2R1bGVJbmRpY2F0b3IpO1xufVxuIl19